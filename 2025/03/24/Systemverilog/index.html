<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Systemverilog | RJ's rotten pen</title><meta name="author" content="huangrj"><meta name="copyright" content="huangrj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、介绍（1）Introduction​	Systemverilog是verilog的扩展，具有许多验证特性，允许使用复杂的TB结构和随机激励来验证设计。 ​	Sytemverilog远远优于Verilog，它能够执行受约束的随机激励，在TB中构建使用OOP特性，功能覆盖率和断言等。 （2）Systemverilog Testbench​	Testbench允许我们通过仿真来验证设计的功能，它是一">
<meta property="og:type" content="article">
<meta property="og:title" content="Systemverilog">
<meta property="og:url" content="https://huang-commits.github.io/2025/03/24/Systemverilog/index.html">
<meta property="og:site_name" content="RJ&#39;s rotten pen">
<meta property="og:description" content="一、介绍（1）Introduction​	Systemverilog是verilog的扩展，具有许多验证特性，允许使用复杂的TB结构和随机激励来验证设计。 ​	Sytemverilog远远优于Verilog，它能够执行受约束的随机激励，在TB中构建使用OOP特性，功能覆盖率和断言等。 （2）Systemverilog Testbench​	Testbench允许我们通过仿真来验证设计的功能，它是一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huang-commits.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-24T08:50:20.000Z">
<meta property="article:modified_time" content="2025-03-27T05:41:59.447Z">
<meta property="article:author" content="huangrj">
<meta property="article:tag" content="Systemverilog">
<meta property="article:tag" content="testbench">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huang-commits.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Systemverilog",
  "url": "https://huang-commits.github.io/2025/03/24/Systemverilog/",
  "image": "https://huang-commits.github.io/img/butterfly-icon.png",
  "datePublished": "2025-03-24T08:50:20.000Z",
  "dateModified": "2025-03-27T05:41:59.447Z",
  "author": [
    {
      "@type": "Person",
      "name": "huangrj",
      "url": "https://huang-commits.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huang-commits.github.io/2025/03/24/Systemverilog/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Systemverilog',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/FPGA/"><i class="fa-fw fas fa-microchip"></i><span> FPGA</span></a></li><li><a class="site-page child" href="/Verilog-HDL/"><i class="fa-fw fas fa-code"></i><span> Verilog-HDL</span></a></li><li><a class="site-page child" href="/Systemverilog/"><i class="fa-fw fas fa-code"></i><span> SystemVerilog</span></a></li><li><a class="site-page child" href="/UVM/"><i class="fa-fw fas fa-code"></i><span> UVM</span></a></li><li><a class="site-page child" href="/VHDL/"><i class="fa-fw fas fa-code"></i><span> VHDL</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">RJ's rotten pen</span></a><a class="nav-page-title" href="/"><span class="site-name">Systemverilog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/FPGA/"><i class="fa-fw fas fa-microchip"></i><span> FPGA</span></a></li><li><a class="site-page child" href="/Verilog-HDL/"><i class="fa-fw fas fa-code"></i><span> Verilog-HDL</span></a></li><li><a class="site-page child" href="/Systemverilog/"><i class="fa-fw fas fa-code"></i><span> SystemVerilog</span></a></li><li><a class="site-page child" href="/UVM/"><i class="fa-fw fas fa-code"></i><span> UVM</span></a></li><li><a class="site-page child" href="/VHDL/"><i class="fa-fw fas fa-code"></i><span> VHDL</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Systemverilog</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-24T08:50:20.000Z" title="发表于 2025-03-24 16:50:20">2025-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-27T05:41:59.447Z" title="更新于 2025-03-27 13:41:59">2025-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Systemverilog/">Systemverilog</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="（1）Introduction"><a href="#（1）Introduction" class="headerlink" title="（1）Introduction"></a>（1）Introduction</h3><p>​	Systemverilog是verilog的扩展，具有许多验证特性，允许使用复杂的TB结构和随机激励来验证设计。</p>
<p>​	Sytemverilog远远优于Verilog，它能够执行受约束的随机激励，在TB中构建使用OOP特性，功能覆盖率和断言等。</p>
<h3 id="（2）Systemverilog-Testbench"><a href="#（2）Systemverilog-Testbench" class="headerlink" title="（2）Systemverilog Testbench"></a>（2）Systemverilog Testbench</h3><p>​	Testbench允许我们通过仿真来验证设计的功能，它是一个容器，设计被放入其中，并采用不同的输入激励。</p>
<p>Testbench的组成：</p>
<p>**Generator：**生成不同的输入激励驱动到DUT</p>
<p>**Interface：**约束被驱动和监控的设计信号，容纳所有的输入输出信号，便于管理</p>
<p>**Driver：**驱动生成的激励到设计中</p>
<p>**Monitor：**监控DUT处理后的数据，并将其转换为transaction，发送到scoreboard</p>
<p>**Scoreboard：**比较DUT和reference model输出的差别，检查DUT的输出是否与预期相符</p>
<p>**Environment：**包含以上所有的验证组件，使验证环境更加灵活和可扩展</p>
<p>**Test：**测试将实例化一个environment对象，并按照测试想要的方式配置它</p>
<p><img src="C:\Users\huangrj\AppData\Roaming\Typora\typora-user-images\image-20250303172939638.png" alt="image-20250303172939638"></p>
<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p><img src="https://www.chipverify.com/images/systemverilog/systemverilog-datatypes.svg" alt="SystemVerilog data types"></p>
<p>下面是variable或net类型可以保持的4种不同状态。</p>
<table>
<thead>
<tr>
<th>0</th>
<th>Logic state 0 - variable&#x2F;net is at 0 volts</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Logic state 1 - variable&#x2F;net is at some value &gt; 0.7 volts</td>
</tr>
<tr>
<td>x or X</td>
<td>Logic state X - variable&#x2F;net has either 0&#x2F;1 - we just don’t know</td>
</tr>
<tr>
<td>z or Z</td>
<td>Logic state Z - net具有高阻抗，可能wire未连接或者悬空</td>
</tr>
</tbody></table>
<h2 id="三、控制流程"><a href="#三、控制流程" class="headerlink" title="三、控制流程"></a>三、控制流程</h2><h3 id="（一）-Loops"><a href="#（一）-Loops" class="headerlink" title="（一） Loops"></a>（一） Loops</h3><table>
<thead>
<tr>
<th>forever</th>
<th>Runs the given set of statements forever</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>Repeats the given set of statements for a given number of times</td>
</tr>
<tr>
<td>while</td>
<td>Repeats the given set of statments as long as given condition is true</td>
</tr>
<tr>
<td>for</td>
<td>Similar to while loop, but more condense and popular form</td>
</tr>
<tr>
<td>do while</td>
<td>Repeats the given set of statements atleast once, and then loops as long as condition is true</td>
</tr>
<tr>
<td>foreach</td>
<td>Used mainly to iterate through all elements in an array</td>
</tr>
</tbody></table>
<h3 id="（二）break-continue"><a href="#（二）break-continue" class="headerlink" title="（二）break, continue"></a>（二）break, continue</h3><h3 id="（三）if-else-if"><a href="#（三）if-else-if" class="headerlink" title="（三）if-else-if"></a>（三）if-else-if</h3><h3 id="（四）case"><a href="#（四）case" class="headerlink" title="（四）case"></a>（四）case</h3><h3 id="（五）Blocking-Non-blocking-Statements"><a href="#（五）Blocking-Non-blocking-Statements" class="headerlink" title="（五）Blocking &amp; Non-blocking Statements"></a>（五）Blocking &amp; Non-blocking Statements</h3><h3 id="（六）Functions"><a href="#（六）Functions" class="headerlink" title="（六）Functions"></a>（六）Functions</h3><h3 id="（七）Tasks"><a href="#（七）Tasks" class="headerlink" title="（七）Tasks"></a>（七）Tasks</h3><h2 id="四、Processes"><a href="#四、Processes" class="headerlink" title="四、Processes"></a>四、Processes</h2><h3 id="（一）systemverilog-thread"><a href="#（一）systemverilog-thread" class="headerlink" title="（一）systemverilog thread"></a>（一）systemverilog thread</h3><p>​	线程或进程是作为单独实体执行的任何一段代码。在verilog中，每个initial和always块都作为单独的线程生成，这些线程从零时间开始并行运行。fork-join还创建并行运行的不同线程。</p>
<p>​	有三种不同类型的fork-join块</p>
<p><img src="https://www.chipverify.com/images/uvm/fork-join.png" alt="fork-join"></p>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-example">fork join</a></th>
<th>所有子线程都结束时完成</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-any-example">fork join_any</a></td>
<td>任意一个子线程结束时完成</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.chipverify.com/systemverilog/systemverilog-threads#fork-join-none-example">fork join_none</a></td>
<td>生成子线程不久之后完成</td>
</tr>
</tbody></table>
<p><strong>线程如何在Testbench中发挥作用？</strong></p>
<p>​	验证环境中的组件可能需要同时运行多个任务的能力。例如，一个进程可能等待某事发生，而另一个进程继续执行其他任务。它们都是通过fork… join作为独立的线程生成的。例如，checker可以并行生成不同的任务来捕获和验证来自Testbench不同部分的数据。</p>
<p>​	<strong>fork-join</strong>之后的代码仅在fork-join中生成的所有线程都完成时才执行。因此，checker必须等到fork-join中生成的所有线程都完成，然后才能继续。</p>
<p>​	<strong>fork-join_any</strong>等待任意一个fork进程完成之后退出fork块。</p>
<p>​	<strong>fork-join_none</strong>不会等待并立即退出fork块，允许fork进程在后台运行。主线程恢复执行fork-join_none块之后的语句。</p>
<p>我们为什么需要<strong>automatic task</strong>？</p>
<p>​	如果不使用<strong>automatic</strong>关键字，那么task被视为静态方法，其内部所有声明的变量都是static。这意味着过程的参数和局部变量都没有调用堆栈。其内部所有的变量内存仅分配一次，所以在不同位置调用同一个方法时，打印的结果是相同的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Main Thread: Fork join going to start&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">          print (<span class="number">20</span>, <span class="string">&quot;Thread1_0&quot;</span>);</span><br><span class="line">          print (<span class="number">30</span>, <span class="string">&quot;Thread1_1&quot;</span>);</span><br><span class="line">          print (<span class="number">10</span>, <span class="string">&quot;Thread2&quot;</span>);</span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Main Thread: Fork join has finished&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that this is not an automatic task, its static</span></span><br><span class="line">  <span class="comment">// 必须使用automatic关键字修饰</span></span><br><span class="line">  <span class="keyword">task</span> print (<span class="keyword">int</span> _time, <span class="keyword">string</span> t_name);</span><br><span class="line">    <span class="variable">#(_time) $display (&quot;[%0t] %s&quot;, $time, t_name)</span>;</span><br><span class="line">  <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[<span class="number">0</span>] Main Thread: Fork <span class="keyword">join</span> going to start</span><br><span class="line">[<span class="number">0</span>] Main Thread: Fork <span class="keyword">join</span> has finished</span><br><span class="line">[<span class="number">10</span>] Thread2</span><br><span class="line">[<span class="number">20</span>] Thread2</span><br><span class="line">[<span class="number">30</span>] Thread2</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>

<p>​	如果没有<strong>automatic</strong>关键字，具有不同字符串标签的相同display task将产生相同的显示信息。这是因为多个线程调用相同的任务并在工具模拟内存中共享相同的变量。为了让不同的线程启动同一任务的不同副本，必须使用自动关键字。</p>
<h3 id="（二）Disable-fork-join"><a href="#（二）Disable-fork-join" class="headerlink" title="（二）Disable fork join"></a>（二）Disable fork join</h3><p>​	所有被fork-join发起的活动线程，都可以被disable fork终结。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">   		<span class="comment">// Fork off 3 sub-threads in parallel and the currently executing main thread</span></span><br><span class="line">      	<span class="comment">// will finish when any of the 3 sub-threads have finished.</span></span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Thread1 : Will finish first at time 40ns</span></span><br><span class="line">         #<span class="number">40</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #40 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Thread2 : Will finish at time 70ns</span></span><br><span class="line">         <span class="keyword">begin</span></span><br><span class="line">            #<span class="number">20</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #20 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">            #<span class="number">50</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #50 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// Thread3 : Will finish at time 60ns</span></span><br><span class="line">          #<span class="number">60</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] TIMEOUT&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">      <span class="keyword">join_any</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Display as soon as the fork is done</span></span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0tns] Fork join is done, let&#x27;s disable fork&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">disable</span> <span class="keyword">fork</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[20 ns] Show #20 $display statement</span><br><span class="line">[40 ns] Show #40 $display statement</span><br><span class="line">[40ns] Fork join is done, let&#x27;s disable fork</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br><span class="line">ncsim&gt; exit</span><br></pre></td></tr></table></figure>

<h3 id="（三）Wait-fork"><a href="#（三）Wait-fork" class="headerlink" title="（三）Wait fork"></a>（三）Wait fork</h3><p>​	wait fork允许主进程等待，直到所有的fork进程都结束。这在主进程必须生成多个线程的情况下很有用，并在等待所有线程完成之前执行一些功能。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// Fork off 3 sub-threads in parallel and the currently executing main thread</span></span><br><span class="line">		<span class="comment">// will finish when any of the 3 sub-threads have finished.</span></span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Thread1 : Will finish first at time 40ns</span></span><br><span class="line">			#<span class="number">40</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #40 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Thread2 : Will finish at time 70ns</span></span><br><span class="line">			<span class="keyword">begin</span></span><br><span class="line">				#<span class="number">20</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #20 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">				#<span class="number">50</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Show #50 $display statement&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Thread3 : Will finish at time 60ns</span></span><br><span class="line">			#<span class="number">60</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] TIMEOUT&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">		<span class="keyword">join_any</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Display as soon as the fork is done</span></span><br><span class="line">      	<span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Fork join is done, wait fork to end&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// Wait until all forked processes are over and display</span></span><br><span class="line">      	<span class="keyword">wait</span> <span class="keyword">fork</span>;</span><br><span class="line">      	<span class="built_in">$display</span> (<span class="string">&quot;[%0t ns] Fork join is over&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[<span class="number">20</span> ns] Show #<span class="number">20</span> <span class="built_in">$display</span> statement</span><br><span class="line">[<span class="number">40</span> ns] Show #<span class="number">40</span> <span class="built_in">$display</span> statement</span><br><span class="line">[<span class="number">40</span> ns] Fork <span class="keyword">join</span> is done, <span class="keyword">wait</span> <span class="keyword">fork</span> to <span class="keyword">end</span></span><br><span class="line">[<span class="number">60</span> ns] TIMEOUT</span><br><span class="line">[<span class="number">70</span> ns] Show #<span class="number">50</span> <span class="built_in">$display</span> statement</span><br><span class="line">[<span class="number">70</span> ns] Fork <span class="keyword">join</span> is over</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>



<h2 id="五、通信"><a href="#五、通信" class="headerlink" title="五、通信"></a>五、通信</h2><h3 id="（一）进程间通信"><a href="#（一）进程间通信" class="headerlink" title="（一）进程间通信"></a>（一）进程间通信</h3><p>​	Testbench中的component经常需要相互通信以交换数据并检查设计的输出值。下表展示了一下允许component或threads影响控制数据流的机制。</p>
<table>
<thead>
<tr>
<th>Events</th>
<th>Testbench中的不同线程通过event句柄进行同步</th>
</tr>
</thead>
<tbody><tr>
<td>Semaphores（信号量）</td>
<td>不同的线程可能需要访问相同的资源；它们轮流使用信号量</td>
</tr>
<tr>
<td>Mailbox（信箱）</td>
<td>Threads&#x2F;Component需要相互交换数据；数据放入mailbox并发送</td>
</tr>
</tbody></table>
<p><strong>什么是Event？</strong></p>
<p>​	Event是同步两个或多个不同进程的一种方式，一个进程等待event发生，而另一个进程触发event，当event被触发时，等待event的进程将恢复执行。</p>
<ul>
<li><strong>创建event</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> 	eventA;  	<span class="comment">// Creates an event called &quot;eventA&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>触发event</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;eventA; 		<span class="comment">// Any process that has access to &quot;eventA&quot; can trigger the event</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>等待event发生（两种方式）</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@eventA; 						<span class="comment">// Use &quot;@&quot; operator to wait for an event</span></span><br><span class="line"><span class="keyword">wait</span> (eventA<span class="variable">.triggered</span>);		<span class="comment">// Or use the wait statement with &quot;eventA.triggered&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>将event作为参数传递到functions</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">	<span class="keyword">event</span> eventA; 		<span class="comment">// Declare an event handle called  &quot;eventA&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">fork</span></span><br><span class="line">			waitForTrigger (eventA);    <span class="comment">// Task waits for eventA to happen</span></span><br><span class="line">			#<span class="number">5</span> -&gt;eventA;                <span class="comment">// Triggers eventA</span></span><br><span class="line">		<span class="keyword">join</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The event is passed as an argument to this task. It simply waits for the event</span></span><br><span class="line">	<span class="comment">// to be triggered</span></span><br><span class="line">	<span class="keyword">task</span> waitForTrigger (<span class="keyword">event</span> eventA);</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;[%0t] Waiting for EventA to be triggered&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">		<span class="keyword">wait</span> (eventA<span class="variable">.triggered</span>);</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;[%0t] EventA has triggered&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>什么是Semaphores？</strong></p>
<p>​	信号量用于控制对资源的访问，称为互斥锁（互斥锁），因为一次只有一个实体可以拥有信号量。可以控制资源不会同时被多个实体访问。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">   semaphore key; 				<span class="comment">// Create a semaphore handle called &quot;key&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      key = <span class="keyword">new</span> (<span class="number">1</span>); 			<span class="comment">// Create only a single key; multiple keys are also possible</span></span><br><span class="line">       							<span class="comment">// 参数&quot;1&quot;在这里表示这个信号量只允许1个实体（任务或线程）同时访问临界区。如果改为更大的数								// 值，那么就可以同时允许多个请求者访问这个“房间”，具体数量由参数值决定。</span></span><br><span class="line">      <span class="keyword">fork</span></span><br><span class="line">         personA (); 			<span class="comment">// personA tries to get the room and puts it back after work</span></span><br><span class="line">         personB (); 			<span class="comment">// personB also tries to get the room and puts it back after work</span></span><br><span class="line">         #<span class="number">25</span> personA (); 		<span class="comment">// personA tries to get the room a second time</span></span><br><span class="line">      <span class="keyword">join_none</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">task</span> getRoom (<span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] id);</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Trying to get a room for id[%0d] ...&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">      key<span class="variable">.get</span> (<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Room Key retrieved for id[%0d]&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">   <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">task</span> putRoom (<span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] id);</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Leaving room id[%0d] ...&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">      key<span class="variable">.put</span> (<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Room Key put back id[%0d]&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">   <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// This person tries to get the room immediately and puts</span></span><br><span class="line">   <span class="comment">// it back 20 time units later</span></span><br><span class="line">   <span class="keyword">task</span> personA ();</span><br><span class="line">      getRoom (<span class="number">1</span>);</span><br><span class="line">      #<span class="number">20</span> putRoom (<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This person tries to get the room after 5 time units and puts it back after</span></span><br><span class="line">  <span class="comment">// 10 time units</span></span><br><span class="line">   <span class="keyword">task</span> personB ();</span><br><span class="line">      #<span class="number">5</span>  getRoom (<span class="number">2</span>);</span><br><span class="line">      #<span class="number">10</span> putRoom (<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[0] Trying to get a room for id[1] ...</span><br><span class="line">[0] Room Key retrieved for id[1]</span><br><span class="line">[5] Trying to get a room for id[2] ...</span><br><span class="line">[20] Leaving room id[1] ...</span><br><span class="line">[20] Room Key put back id[1]</span><br><span class="line">[20] Room Key retrieved for id[2]</span><br><span class="line">[25] Trying to get a room for id[1] ...</span><br><span class="line">[30] Leaving room id[2] ...</span><br><span class="line">[30] Room Key put back id[2]</span><br><span class="line">[30] Room Key retrieved for id[1]</span><br><span class="line">[50] Leaving room id[1] ...</span><br><span class="line">[50] Room Key put back id[1]</span><br></pre></td></tr></table></figure>

<p>关于<strong>semaphore</strong>需要注意以下几点：</p>
<ul>
<li>使用new()函数创建semaphore对象key。new()的参数定义key的数量</li>
<li>可以使用get()关键字获取key，该关键字将一直等到key可用(阻塞)</li>
<li>可以使用put()关键字将key放回</li>
</ul>
<p>什么是<strong>mailbox</strong>？</p>
<p>​	mailbox就像一个专用通道，用于在两个component之间传送数据。</p>
<p>​	例如，可以创建一个mailbox，并将句柄传送到data generate和driver。generate可以将数据对象推送到mailbox中，driver将能够检索数据包并将信号驱动到总线(bus)上。</p>
<h3 id="（二）Event"><a href="#（二）Event" class="headerlink" title="（二）Event"></a>（二）Event</h3><p>​	event是一个静态对象句柄，用于在两个或多个并发活动的进程之间进行同步。一个进程将触发事件，另一个进程等待事件。</p>
<ul>
<li>可以分配或与其他事件变量进行比较<ul>
<li>可以分配给 <code>null</code></li>
<li>当分配给另一个事件时，两个变量都指向同一个同步对象</li>
</ul>
</li>
<li>可以传递给queue、function和task</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event  over;                     // a new event is created called over</span><br><span class="line">event  over_again = over;        // over_again becomes an alias to over</span><br><span class="line">event  empty = null;             // event variable with no synchronization object 没有同步对象的event变量</span><br></pre></td></tr></table></figure>

<p><strong>如何触发和等待event？</strong></p>
<ul>
<li>命名事件可以使用<code>-&gt;</code>或者<code>-&gt;&gt;</code>操作符触发</li>
<li>进程可以使用<code>@</code>操作符或<code>.triggered</code>来等待事件触发</li>
</ul>
<p><strong><code>@</code>和<code>.triggered</code>有什么区别？</strong></p>
<p>​	一个事件的triggered会在整个时间步长内持续存在，直至仿真推进。因此，如果<code>wait</code>该事件和<code>trigger</code>该事件这两个操作同时发生，就会出现竞争条件，而<code>triggered</code>属性有助于避免这种情况。</p>
<ul>
<li><strong><code>@</code> 操作符</strong>：用于等待特定事件或信号变化的发生，并在此事件发生时继续执行后续代码。</li>
<li><strong><code>.triggered</code> 属性</strong>：用于检查某个事件是否已经被触发，不阻塞当前进程的执行，适合用于状态检查。</li>
</ul>
<p>​	一个等待触发状态的进程总会被解除阻塞，而无论等待和触发的顺序如何。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an event variable that processes can use to trigger and wait</span></span><br><span class="line">  <span class="keyword">event</span> event_a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread1: Triggers the event using &quot;-&gt;&quot; operator at 20ns</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    #<span class="number">20</span> -&gt;event_a;</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread1: triggered event_a&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread2: Starts waiting for the event using &quot;@&quot; operator at 20ns</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread2: waiting for trigger &quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">    #<span class="number">20</span> @(event_a);</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread2: received event_a trigger &quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread3: Starts waiting for the event using &quot;.triggered&quot; at 20ns</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread3: waiting for trigger &quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">    #<span class="number">20</span> <span class="keyword">wait</span>(event_a<span class="variable">.triggered</span>);</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread3: received event_a trigger&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[0] Thread2: waiting for trigger </span><br><span class="line">[0] Thread3: waiting for trigger </span><br><span class="line">[20] Thread1: triggered event_a</span><br><span class="line">[20] Thread3: received event_a trigger</span><br><span class="line"><span class="section">ncsim: *W,RNQUIE: Simulation is complete.</span></span><br></pre></td></tr></table></figure>

<p>由于<code>@</code>和<code>-&gt;</code>操作符之间存在的<strong>竞争</strong>条件，Thread2没有接受到触发。</p>
<p><strong>wait_order</strong></p>
<p>等待事件按照给定的顺序被触发，如果有任何事件未按顺序执行，则会发出错误提示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="comment">// Declare three events that can be triggered separately</span></span><br><span class="line">  <span class="keyword">event</span> a, b, c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This block triggers each event one by one</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    #<span class="number">10</span> -&gt; a;</span><br><span class="line">    #<span class="number">10</span> -&gt; b;</span><br><span class="line">    #<span class="number">10</span> -&gt; c;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This block waits until each event is triggered in the given order</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wait_order</span> (a,b,c)</span><br><span class="line">    	<span class="built_in">$display</span> (<span class="string">&quot;Events were executed in the correct order&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      	<span class="built_in">$display</span> (<span class="string">&quot;Events were NOT executed in the correct order !&quot;</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<p><strong>Merging Event</strong></p>
<p>​	当一个event变量被赋值给另一个event变量时，所有等待第一个事件触发的进程都将等到第二个变量被触发。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create event variables</span></span><br><span class="line">  <span class="keyword">event</span> event_a, event_b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">      <span class="comment">// Thread1: waits for event_a to be triggered</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">wait</span>(event_a<span class="variable">.triggered</span>);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread1: Wait for event_a is over&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  	  <span class="comment">// Thread2: waits for event_b to be triggered</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">wait</span>(event_b<span class="variable">.triggered</span>);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread2: Wait for event_b is over&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Thread3: triggers event_a at 20ns</span></span><br><span class="line">      #<span class="number">20</span> -&gt;event_a;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Thread4: triggers event_b at 30ns</span></span><br><span class="line">      #<span class="number">30</span> -&gt;event_b;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Thread5: Assigns event_b to event_a at 10ns</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// Comment code below and try again to see Thread2 finish later</span></span><br><span class="line">        <span class="comment">// event_a 和 event_b 同时被触发</span></span><br><span class="line">        #<span class="number">10</span> event_b = event_a;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[20] Thread1: Wait for event_a is over</span><br><span class="line">[20] Thread2: Wait for event_b is over</span><br><span class="line"><span class="section">ncsim: *W,RNQUIE: Simulation is complete.</span></span><br></pre></td></tr></table></figure>



<h3 id="（三）Semaphores信号量"><a href="#（三）Semaphores信号量" class="headerlink" title="（三）Semaphores信号量"></a>（三）Semaphores信号量</h3><p>​	信号量就像一个装有固定数量键的存储桶，使用信号量的进程必须先从存储桶中获得一个键，然后才能继续执行，其他进程必须等到存储桶中有了键才能使用。从某种意义上说，信号量最适合用于实现互斥、对共享资源进行访问控制以及基本的同步操作。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore 	[identifier_name];</span><br></pre></td></tr></table></figure>

<p>​	<code>Semaphore</code>是一个内置类，因此它应该像任何其他类对象一样使用。它有一些方法，我们可以使用这些方法为该<strong>信号量对象</strong>分配键的数量，获取并将键放入存储桶。</p>
<p><strong>Method</strong></p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">function new (int keyCount &#x3D; 0);</td>
<td align="left">指定最初分配给信号量存储桶的键数</td>
</tr>
<tr>
<td align="left">function void put (int keyCount &#x3D; 1);</td>
<td align="left">指定返回到信号量的键数</td>
</tr>
<tr>
<td align="left">task get (int keyCount &#x3D; 1);</td>
<td align="left">指定从信号量中获取的键数</td>
</tr>
<tr>
<td align="left">function int try_get (int keyCount &#x3D; 1);</td>
<td align="left">指定从信号量获取所需的键数</td>
</tr>
</tbody></table>
<p><strong>Example</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">module tb_top;</span><br><span class="line">   semaphore key;</span><br><span class="line"></span><br><span class="line">   initial begin</span><br><span class="line">      key = new (1);</span><br><span class="line">      fork</span><br><span class="line">         personA ();</span><br><span class="line">         personB ();</span><br><span class="line">         #25 personA ();</span><br><span class="line">      join_none</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   task getRoom (bit [1:0] id);</span><br><span class="line">      $display (&quot;[%0t] Trying to get a room for id[%0d] ...&quot;, $time, id);</span><br><span class="line">      key.get (1);</span><br><span class="line">      $display (&quot;[%0t] Room Key retrieved for id[%0d]&quot;, $time, id);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   task putRoom (bit [1:0] id);</span><br><span class="line">      $display (&quot;[%0t] Leaving room id[%0d] ...&quot;, $time, id);</span><br><span class="line">      key.put (1);</span><br><span class="line">      $display (&quot;[%0t] Room Key put back id[%0d]&quot;, $time, id);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   task personA ();</span><br><span class="line">      getRoom (1);</span><br><span class="line">      #20 putRoom (1);</span><br><span class="line">   endtask</span><br><span class="line"></span><br><span class="line">   task personB ();</span><br><span class="line">      #5  getRoom (2);</span><br><span class="line">      #10 putRoom (2);</span><br><span class="line">   endtask</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[0] Trying to get a room for id[1] ...</span><br><span class="line">[0] Room Key retrieved for id[1]</span><br><span class="line">[5] Trying to get a room for id[2] ...</span><br><span class="line">[20] Leaving room id[1] ...</span><br><span class="line">[20] Room Key put back id[1]</span><br><span class="line">[20] Room Key retrieved for id[2]</span><br><span class="line">[25] Trying to get a room for id[1] ...</span><br><span class="line">[30] Leaving room id[2] ...</span><br><span class="line">[30] Room Key put back id[2]</span><br><span class="line">[30] Room Key retrieved for id[1]</span><br><span class="line">[50] Leaving room id[1] ...</span><br><span class="line">[50] Room Key put back id[1]</span><br></pre></td></tr></table></figure>



<h3 id="（四）Mailboxes"><a href="#（四）Mailboxes" class="headerlink" title="（四）Mailboxes"></a>（四）Mailboxes</h3><p>​	SystemVerilog <code>Mailbox</code>是一种允许不同进程之间交换数据的方式。它类似于真正的邮箱，可以将信件放入邮箱，然后人们可以在以后取回这些信件。</p>
<p>​	SystemVerilog <code>Mailbox</code>的创建可设置为具有有界或无界的队列大小。有界邮箱只能存储有限数量的数据，如果一个进程试图往已满的邮箱中存储更多消息，该进程将被挂起，直到邮箱中有足够的空间。不过，无界邮箱的大小是没有限制的。</p>
<p>有两种类型的Mailbox：</p>
<ul>
<li><p>可以接受任何数据类型的项目的通用邮箱（Gnenric Mailbox）</p>
</li>
<li><p>只能接受特定数据类型的项目的参数化邮箱（Parameterized Mailbox）</p>
</li>
</ul>
<p><strong>systemverilog Mailbox vs Queue</strong></p>
<p>​	虽然SystemVerilog邮箱本质上表现得像一个队列，但它与Queue数据类型有很大不同。一个简单的队列只能从前面或后面推送和弹出item。然而，<em>mailbox</em>是一个内置类，它使用<code>semaphore</code>对队列中的push和pop进行原子控制。此外，不允许直接对mailbox进行索引访问，而只能按FIFO顺序检索项目。</p>
<h4 id="1-基础数据结构对比"><a href="#1-基础数据结构对比" class="headerlink" title="1. 基础数据结构对比"></a>1. <strong>基础数据结构对比</strong></h4><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>队列 (queue)</strong></th>
<th align="left"><strong>邮箱 (mailbox)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据结构类型</strong></td>
<td align="left">原生动态数组</td>
<td align="left">内置类 (built-in class)</td>
</tr>
<tr>
<td align="left"><strong>并发控制</strong></td>
<td align="left">无内置线程安全机制</td>
<td align="left">通过信号量 (semaphores) 实现原子操作</td>
</tr>
<tr>
<td align="left"><strong>访问方式</strong></td>
<td align="left">支持随机访问 (<code>queue[N]</code>)</td>
<td align="left">仅支持 FIFO 顺序访问</td>
</tr>
<tr>
<td align="left"><strong>操作边界</strong></td>
<td align="left">可从队首 (<code>push_front</code>&#x2F;<code>pop_front</code>) 或队尾 (<code>push_back</code>&#x2F;<code>pop_back</code>) 操作</td>
<td align="left">仅支持顺序插入 (<code>put</code>) 和取出 (<code>get</code>)</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-底层实现差异"><a href="#2-底层实现差异" class="headerlink" title="2. 底层实现差异"></a>2. <strong>底层实现差异</strong></h4><p><strong>队列操作示例（非线程安全）</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int q[$]; </span><br><span class="line">// 线程A</span><br><span class="line">q.push<span class="emphasis">_back(10);  // 尾部插入</span></span><br><span class="line"><span class="emphasis">// 线程B</span></span><br><span class="line"><span class="emphasis">int val = q.pop_</span>front();  // 头部取出（可能发生数据竞争）</span><br></pre></td></tr></table></figure>

<p><strong>邮箱操作示例（线程安全）</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mailbox mb = new(); </span><br><span class="line">// 线程A</span><br><span class="line">mb.put(10);  // 原子性插入（信号量保护）</span><br><span class="line">// 线程B</span><br><span class="line">int val;</span><br><span class="line">mb.get(val);  // 原子性取出（FIFO 顺序，信号量保护）</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-关键设计约束"><a href="#3-关键设计约束" class="headerlink" title="3. 关键设计约束"></a>3. <strong>关键设计约束</strong></h4><ul>
<li><strong>不可随机访问</strong>：邮箱底层虽为队列结构，但<strong>禁止直接索引访问</strong>（如 <code>mb[2]</code> 非法）</li>
<li><strong>阻塞&#x2F;非阻塞模式</strong>：邮箱支持 <code>try_put()</code>&#x2F;<code>try_get()</code> 非阻塞操作，队列无此语义</li>
<li><strong>容量控制</strong>：邮箱可设置最大容量（有界邮箱），队列长度仅受内存限制</li>
</ul>
<hr>
<p><strong>典型应用场景</strong>：</p>
<ul>
<li><strong>队列</strong>：单线程场景下的快速数据缓冲（如数据包重组）</li>
<li><strong>邮箱</strong>：多线程间通信（如生产者-消费者模型、异步事务传递）</li>
</ul>
<p>SystemVerilog <code>mailbox</code>通常在有多个线程并行运行并希望共享需要一定级别确定性的数据时使用。</p>
<p><strong>Generic Mailbox Example</strong></p>
<p>​	在下面显示的示例中，两个进程同时处于活动状态，其中一个初始块将数据放入邮箱，另一个初始块从邮箱获取数据。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="comment">// Create a new mailbox that can hold utmost 2 items</span></span><br><span class="line">  	mailbox 	mbx = <span class="keyword">new</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Block1: This block keeps putting items into the mailbox</span></span><br><span class="line">  	<span class="comment">// The rate of items being put into the mailbox is 1 every ns</span></span><br><span class="line">  	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="keyword">begin</span></span><br><span class="line">        	#<span class="number">1</span> mbx<span class="variable">.put</span> (i);</span><br><span class="line">        	<span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread0: Put item #%0d, size=%0d&quot;</span>, <span class="built_in">$time</span>, i, mbx<span class="variable">.num</span>());</span><br><span class="line">      	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Block2: This block keeps getting items from the mailbox</span></span><br><span class="line">  	<span class="comment">// The rate of items received from the mailbox is 2 every ns</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">int</span> idx;</span><br><span class="line">			#<span class="number">2</span> mbx<span class="variable">.get</span> (idx);</span><br><span class="line">          	<span class="built_in">$display</span> (<span class="string">&quot;[%0t] Thread1: Got item #%0d, size=%0d&quot;</span>, <span class="built_in">$time</span>, idx, mbx<span class="variable">.num</span>());</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	这两个线程之间存在<strong>竞争</strong>情况，在同一个delta周期内，第一个线程可能会向邮箱中存入数据，而第二个线程可能会从邮箱中取出数据。因此，使用 <code>num()</code> 函数显示的值仅在下一次对该邮箱执行 <code>get</code>（取出）或 <code>put</code>（存入）操作之前是有效的，并且该值可能取决于其他方法的开始和结束时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[1] Thread0: Put item #0, size=1</span><br><span class="line">[2] Thread1:   Got item #0, size=0</span><br><span class="line">[2] Thread0: Put item #1, size=1</span><br><span class="line">[3] Thread0: Put item #2, size=2</span><br><span class="line">[4] Thread1:   Got item #1, size=1</span><br><span class="line">[4] Thread0: Put item #3, size=2</span><br><span class="line">[6] Thread1:   Got item #2, size=2</span><br><span class="line">[6] Thread0: Put item #4, size=2</span><br><span class="line">[8] Thread1:   Got item #3, size=1</span><br><span class="line">[10] Thread1:   Got item #4, size=0</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>



<p>Systemverilog Mailbox Functions and Methods</p>
<table>
<thead>
<tr>
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">function <strong>new</strong> (int bound &#x3D; 0);</td>
<td align="left">Returns a mailbox handle, bound &gt; 0 represents size of mailbox queue</td>
</tr>
<tr>
<td align="left">function int <strong>num</strong> ();</td>
<td align="left">Returns the number of messages currently in the mailbox</td>
</tr>
<tr>
<td align="left">task <strong>put</strong> (singular message);</td>
<td align="left">Blocking method that stores a message in the mailbox in FIFO order; message is any singular expression</td>
</tr>
<tr>
<td align="left">function int <strong>try_put</strong> (singular message);</td>
<td align="left">Non-blocking method that stores a message if the mailbox is not full, returns a postive integer if successful else 0</td>
</tr>
<tr>
<td align="left">task <strong>get</strong> (ref singular message);</td>
<td align="left">Blocking method until it can retrieve one message from the mailbox, if empty blocks the process</td>
</tr>
<tr>
<td align="left">function int <strong>try_get</strong> (ref singular message);</td>
<td align="left">Non-blocking method which tries to get one message from the mailbox, returns 0 if empty</td>
</tr>
<tr>
<td align="left">task <strong>peek</strong> (ref singular message);</td>
<td align="left">Copies one message from the mailbox without removing the message from the mailbox queue.</td>
</tr>
<tr>
<td align="left">function int <strong>try_peek</strong> (ref singular message);</td>
<td align="left">Tries to copy one message from the mailbox without removing the message from queue</td>
</tr>
</tbody></table>
<p><strong>Parameterized Mailbox</strong></p>
<p>​	默认情况下，SystemVerilog mailbox是无类型的，因此可以发送和接收混合数据类型的对象。尽管这是一个很好的功能，但它可能会在仿真期间导致类型不匹配并导致错误。要限制mailbox接受和发送固定数据类型的对象，可以将其参数化为该特定数据类型。</p>
<p><strong>Example</strong></p>
<p>​	在下面显示的示例中，首先使用 <code>typedef</code> 结构为能够收发字符串的mailbox创建了一个别名。尽管这一步是可选的，但这是一个很好的做法，有助于避免因<strong>编码错误</strong>导致不同组件之间出现类型不匹配的问题。假设组件 1（comp1）要通过这个邮箱向组件 2（comp2）发送一些字符串。显然，这两个类都需要有一个邮箱句柄，并且需要将它们连接起来，而最好在顶层或者实例化这两个类的模块中完成这个连接操作。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create alias for parameterized &quot;string&quot; type mailbox</span></span><br><span class="line"><span class="keyword">typedef</span> mailbox <span class="variable">#(string)</span> s_mbox;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a component to send messages</span></span><br><span class="line"><span class="keyword">class</span> comp1;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Create a mailbox handle to put items</span></span><br><span class="line">  	s_mbox 	names;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Define a task to put items into the mailbox</span></span><br><span class="line">	<span class="keyword">task</span> send ();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">string</span> s = <span class="built_in">$sformatf</span> (<span class="string">&quot;name_%0d&quot;</span>, i);</span><br><span class="line">          #<span class="number">1</span> <span class="built_in">$display</span> (<span class="string">&quot;[%0t] Comp1: Put %s&quot;</span>, <span class="built_in">$time</span>, s);</span><br><span class="line">			names<span class="variable">.put</span>(s);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a second component to receive messages</span></span><br><span class="line"><span class="keyword">class</span> comp2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a mailbox handle to receive items</span></span><br><span class="line">	s_mbox 	list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// Create a loop that continuously gets an item from</span></span><br><span class="line">  	<span class="comment">// the mailbox</span></span><br><span class="line">	<span class="keyword">task</span> receive ();</span><br><span class="line">		<span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">string</span> s;</span><br><span class="line">			list<span class="variable">.get</span>(s);</span><br><span class="line">          	<span class="built_in">$display</span> (<span class="string">&quot;[%0t]    Comp2: Got %s&quot;</span>, <span class="built_in">$time</span>, s);</span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect both mailbox handles at a higher level</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  	<span class="comment">// Declare a global mailbox and create both components</span></span><br><span class="line">  	s_mbox 	m_mbx    = <span class="keyword">new</span>();</span><br><span class="line">  	comp1 	m_comp1  = <span class="keyword">new</span>();</span><br><span class="line">  	comp2 	m_comp2  = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="comment">// Assign both mailbox handles in components with the</span></span><br><span class="line">      <span class="comment">// global mailbox</span></span><br><span class="line">      <span class="comment">// 在顶层例化mailbox之后赋值即可，不用再在class中实例化mailbox</span></span><br><span class="line">      m_comp1<span class="variable">.names</span> = m_mbx;</span><br><span class="line">      m_comp2<span class="variable">.list</span> = m_mbx;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Start both components, where comp1 keeps sending</span></span><br><span class="line">      <span class="comment">// and comp2 keeps receiving</span></span><br><span class="line">      <span class="keyword">fork</span></span><br><span class="line">      	m_comp1<span class="variable">.send</span>();</span><br><span class="line">        m_comp2<span class="variable">.receive</span>();</span><br><span class="line">      <span class="keyword">join</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[1] Comp1: Put name_0</span><br><span class="line">[1]    Comp2: Got name_0</span><br><span class="line">[2] Comp1: Put name_1</span><br><span class="line">[2]    Comp2: Got name_1</span><br><span class="line">[3] Comp1: Put name_2</span><br><span class="line">[3]    Comp2: Got name_2</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>

<p><strong>Matching different type mailboxs</strong></p>
<p>​	让我们看看如果SystemVerilog mailbox被参数化为不同的数据类型会发生什么。考虑comp1具有<code>string</code>类型，comp2具有<code>byte</code>类型邮箱。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> comp2;</span><br><span class="line">	mailbox <span class="variable">#(byte)</span> 	list;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	s_mbox 	m_mbx;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		m_comp1<span class="variable">.names</span> = m_mbx;</span><br><span class="line">		m_comp2<span class="variable">.list</span>  = m_mbx;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>这将导致编译时错误，进而让我们能够重新审视测试平台代码，以修正类型不匹配的问题。</p>
<h2 id="六、接口-Interface"><a href="#六、接口-Interface" class="headerlink" title="六、接口(Interface)"></a>六、接口(Interface)</h2><h3 id="（一）Interface"><a href="#（一）Interface" class="headerlink" title="（一）Interface"></a>（一）Interface</h3><p><strong>Interface</strong>是一种将信号封装到block中的方法。所有的相关信号将被组合在一起形成一个interface block，以便相同的interface可以在其他的project中重用。此外DUT和其他验证component的连接也变得更加容易。</p>
<p>例如，<strong>APB总线协议</strong>信号在给定的接口中放在一起。请注意，信号在接口和端接口中声明。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> apb_if (<span class="keyword">input</span> pclk);</span><br><span class="line">	<span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>]    paddr;</span><br><span class="line">	<span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>]    pwdata;</span><br><span class="line">	<span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>]    prdata;</span><br><span class="line">	<span class="keyword">logic</span>           penable;</span><br><span class="line">	<span class="keyword">logic</span>           pwrite;</span><br><span class="line">	<span class="keyword">logic</span>           psel;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么信号要声明为logic？</strong></p>
<p>​	logic允许通过assign和procedure block驱动这种类型的信号。在verilog中，只能在过程块中驱动reg，在assign中驱动wire。但这只是其中一个原因。</p>
<p>​	连接到DUT的信号应该支持4状态，以便可以捕获X&#x2F;Z值。如果这些信号是bit，那么X&#x2F;Z将显示为0，将错过DUT中的X&#x2F;Z值。</p>
<p><strong>如何定义port方向？</strong></p>
<p>​	interface信号可以在各种验证组件和DUT中使用，因此<strong>modport</strong>用于定义方向。不同的modport定义可以传递给不同的component，从而允许我们为每个component定义不同的输入输出方向。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> myBus (<span class="keyword">input</span> clk);</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>]  data;</span><br><span class="line">  <span class="keyword">logic</span>      enable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From TestBench perspective, &#x27;data&#x27; is input and &#x27;write&#x27; is output</span></span><br><span class="line">  <span class="keyword">modport</span> TB  (<span class="keyword">input</span> data, clk, <span class="keyword">output</span> enable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From DUT perspective, &#x27;data&#x27; is output and &#x27;enable&#x27; is input</span></span><br><span class="line">  <span class="keyword">modport</span> DUT (<span class="keyword">output</span> data, <span class="keyword">input</span> enable, clk);</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p><strong>如何将Interface连接上DUT？</strong></p>
<p>应该在实例化DUT的top testbench模块中创建一个interface对象，并将其传递给DUT。确保为DUT分配正确的modport非常重要。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dut (myBus busIf);</span><br><span class="line">  <span class="keyword">always</span> @ (<span class="keyword">posedge</span> busIf<span class="variable">.clk</span>)</span><br><span class="line">    <span class="keyword">if</span> (busIf<span class="variable">.enable</span>)</span><br><span class="line">      busIf<span class="variable">.data</span> &lt;= busIf<span class="variable">.data</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      busIf<span class="variable">.data</span> &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Filename : tb_top.sv</span></span><br><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">  <span class="keyword">bit</span> clk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a clock</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an interface object</span></span><br><span class="line">  myBus busIf (clk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate the DUT; pass modport DUT of busIf</span></span><br><span class="line">  dut dut0 (busIf<span class="variable">.DUT</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Testbench code : let&#x27;s wiggle enable</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    busIf<span class="variable">.enable</span>  &lt;= <span class="number">0</span>;</span><br><span class="line">    #<span class="number">10</span> busIf<span class="variable">.enable</span> &lt;= <span class="number">1</span>;</span><br><span class="line">    #<span class="number">40</span> busIf<span class="variable">.enable</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    #<span class="number">20</span> busIf<span class="variable">.enable</span> &lt;= <span class="number">1</span>;</span><br><span class="line">    #<span class="number">100</span> <span class="built_in">$finish</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>使用Interface有什么优点？</strong></p>
<p>​	Interface可以包含task、function、parameter、variable、functional coverage和assertion。这使我们能够通过block中的interface监控和记录事务。无论端口数量如何，连接到design也变得更加容易，因为这些信息被封装在interface中。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Before interface</span></span><br><span class="line">dut dut0  (<span class="variable">.data</span> (data),</span><br><span class="line">           <span class="variable">.enable</span> (enable),</span><br><span class="line">           <span class="comment">//  all other signals</span></span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line"><span class="comment">// With interface - higher level of abstraction possible</span></span><br><span class="line">dut dut0  (busIf<span class="variable">.DUT</span>);</span><br></pre></td></tr></table></figure>

<p><strong>如何参数化interface？</strong></p>
<p>和module的参数化方式相同：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> myBus #(<span class="keyword">parameter</span> D_WIDTH=<span class="number">31</span>) (<span class="keyword">input</span> clk);</span><br><span class="line">	<span class="keyword">logic</span> [D_WIDTH-<span class="number">1</span>:<span class="number">0</span>] data;</span><br><span class="line">	<span class="keyword">logic</span>               enable;</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p>clocking block是什么？</p>
<p>​	在clocking block内指定的信号将相对于该时钟进行采样&#x2F;驱动。Interface中可以有多个clocking block。注意，这是针对Testbench相关信号的。控制TB何时驱动和采样来自DUT的信号。解决竞争条件的某些部分，但不是全部。也可以参数化skew值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> my_int (<span class="keyword">input</span> <span class="keyword">bit</span> clk);</span><br><span class="line">	<span class="comment">// Rest of interface code</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">clocking</span> cb_clk @(<span class="keyword">posedge</span> clk);</span><br><span class="line">		<span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">3</span>ns <span class="keyword">output</span> #<span class="number">2</span>ns;</span><br><span class="line">		<span class="keyword">input</span> enable;</span><br><span class="line">		<span class="keyword">output</span> data;</span><br><span class="line">	<span class="keyword">endclocking</span></span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p>​	在上面的例子中，在指定的default情况下，输入应该在clk上升沿之前3ns进行采样，输出应该在clk的上升沿2ns之后驱动。</p>
<p><strong>如何使用clocking block？</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To wait for posedge of clock</span></span><br><span class="line">@busIf<span class="variable">.cb_clk</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To use clocking block signals</span></span><br><span class="line">busIf<span class="variable">.cb_clk</span><span class="variable">.enable</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>​	正如你所看到的，你不必等到时钟的上升沿才给enable赋值为1。这样，你可以确保使能将在下一个时钟上升沿后2纳秒被驱动。</p>
<h3 id="（二）Introduction"><a href="#（二）Introduction" class="headerlink" title="（二）Introduction"></a>（二）Introduction</h3><p>​	SystemVerilog interface允许将多个信号组合在一起，并将它们表示为单个端口。所有这些信号都可以在一个地方声明和维护，并且很容易维护。接口内的信号由<strong>接口实例句柄</strong>访问。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> [name] ([port_list]);</span><br><span class="line">	[list_of_signals]</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p>​	Interface也可以有functions、tasks、variables和parameters，使其更像一个类模板。它还能够通过<strong>modport</strong>构造为不同的模块端口定义方向信息策略，以及带有<code>clocking blocks</code>的测试台同步功能。它还可以有断言、覆盖记录和其他协议检查元素。最后但并非最不重要的是，它还可以包含initial和alwa以及assign赋值语句。</p>
<blockquote>
<p>module不能在interface中实例化！但是interface可以在module中实例化。</p>
</blockquote>
<p>​	如今，SystemVerilog 作为一种硬件描述语言（HDL）颇为流行。下面我们来看两种情况，即在 Verilog 和 SystemVerilog 中分别将接口应用于同一设计。为了让这个入门示例简单易懂，我们将仅创建一个简单的接口。</p>
<p><strong>Interface with a Verilog Design</strong></p>
<p><img src="https://www.chipverify.com/images/systemverilog/tb-interface-example.png" alt="tb-interface-example"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter_ud</span><br><span class="line">  #(<span class="keyword">parameter</span> WIDTH = <span class="number">4</span>)</span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">input</span> 					clk,</span><br><span class="line">  <span class="keyword">input</span> 					rstn,</span><br><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	load,</span><br><span class="line">  <span class="keyword">input</span> 					load_en,</span><br><span class="line">  <span class="keyword">input</span> 					down,</span><br><span class="line">  <span class="keyword">output</span> 					rollover,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	count</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> cnt_if #(<span class="keyword">parameter</span> WIDTH = <span class="number">4</span>) (<span class="keyword">input</span> <span class="keyword">bit</span> clk);</span><br><span class="line">  <span class="keyword">logic</span> 			rstn;</span><br><span class="line">  <span class="keyword">logic</span> 			load_en;</span><br><span class="line">  <span class="keyword">logic</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] load;</span><br><span class="line">  <span class="keyword">logic</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>] count;</span><br><span class="line">  <span class="keyword">logic</span> 			down;</span><br><span class="line">  <span class="keyword">logic</span> 			rollover;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TB Clock Generator used to provide the design</span></span><br><span class="line">  <span class="comment">// with a clock -&gt; here half_period = 10ns =&gt; 50 MHz</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">  cnt_if 	  cnt_if0 (clk);</span><br><span class="line">  counter_ud  c0 ( 	<span class="variable">.clk</span> 		(cnt_if0<span class="variable">.clk</span>),</span><br><span class="line">                  	<span class="variable">.rstn</span> 		(cnt_if0<span class="variable">.rstn</span>),</span><br><span class="line">                  	<span class="variable">.load</span> 		(cnt_if0<span class="variable">.load</span>),</span><br><span class="line">                  	<span class="variable">.load_en</span> 	(cnt_if0<span class="variable">.load_en</span>),</span><br><span class="line">                  	<span class="variable">.down</span> 		(cnt_if0<span class="variable">.down</span>),</span><br><span class="line">                  	<span class="variable">.rollover</span> 	(cnt_if0<span class="variable">.rollover</span>),</span><br><span class="line">                  	<span class="variable">.count</span> 		(cnt_if0<span class="variable">.count</span>));</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// Initialize testbench variables</span></span><br><span class="line">    clk &lt;= <span class="number">0</span>;</span><br><span class="line">    cnt_if0<span class="variable">.rstn</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    cnt_if0<span class="variable">.load_en</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    cnt_if0<span class="variable">.load</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    cnt_if0<span class="variable">.down</span> &lt;= <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>Interface with a Systemverilog design</strong></p>
<p><img src="https://www.chipverify.com/images/systemverilog/tb-interface-sv-example.png" alt="tb-interface-sv-example"></p>
<p>​	现在让我们来看看如何在测试平台中使用接口，并将其连接到一个 SystemVerilog 设计模块上。SystemVerilog 允许module将interface作为端口列表，而非使用单独的信号。在下面所示的设计示例中，我们用一个接口句柄替换了 <code>counter_ud</code> 模块的端口列表，该接口句柄用于定义设计功能。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This module accepts an interface object as the port list</span></span><br><span class="line"><span class="keyword">module</span> counter_ud  #(<span class="keyword">parameter</span> WIDTH = <span class="number">4</span>) (cnt_if _if);</span><br><span class="line">  <span class="keyword">always</span> @ (<span class="keyword">posedge</span> _if<span class="variable">.clk</span> <span class="keyword">or</span> <span class="keyword">negedge</span> _if<span class="variable">.rstn</span>) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!_if<span class="variable">.rstn</span>)</span><br><span class="line">   		_if<span class="variable">.count</span> &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> (_if<span class="variable">.load_en</span>)</span><br><span class="line">        _if<span class="variable">.count</span> &lt;= _if<span class="variable">.load</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (_if<span class="variable">.down</span>)</span><br><span class="line">        	_if<span class="variable">.count</span> &lt;= _if<span class="variable">.count</span> - <span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">else</span></span><br><span class="line">        	_if<span class="variable">.count</span> &lt;= _if<span class="variable">.count</span> + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> _if<span class="variable">.rollover</span> = &amp;_if<span class="variable">.count</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	在设计实例中传入了一个名为 <code>cnt_if</code> 的接口句柄，该句柄用于从Testbench向设计模块提供输入信号。如有需要，同样的接口句柄也可用于监测设计模块的输出信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface definition is the same as before</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TB Clock Generator used to provide the design</span></span><br><span class="line">  <span class="comment">// with a clock -&gt; here half_period = 10ns =&gt; 50 MHz</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">  cnt_if 	  cnt_if0 (clk);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Note that here we just have to pass the interface handle</span></span><br><span class="line">  <span class="comment">// to the design instead of connecting each individual signal</span></span><br><span class="line">  <span class="comment">// 在这里我们只需将接口句柄传递给设计模块，而无需逐个连接各个单独的信号。</span></span><br><span class="line">  counter_ud  c0 (cnt_if0);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stimulus remains the same as before</span></span><br></pre></td></tr></table></figure>



<p><strong>Using SystemVerilog Interface</strong></p>
<p>​	请注意，模块 <code>d_top</code> 只是使用interface来与从模块实例进行连接，而不是像之前那样重复声明与从模块每个信号的连接。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> slave_if (<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset);</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line">	<span class="keyword">reg</span> reset;</span><br><span class="line">	<span class="keyword">reg</span> enable;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">reg</span> gnt;</span><br><span class="line">	<span class="comment">// Declarations for other signals follow</span></span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_slave (slave_if s_if);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Design functionality</span></span><br><span class="line">	<span class="keyword">always</span> (s_if<span class="variable">.enable</span> &amp; s_if<span class="variable">.gnt</span>) <span class="keyword">begin</span> 	<span class="comment">// interface signals are accessed by the handle &quot;s_if&quot;</span></span><br><span class="line">		<span class="comment">// Some behavior</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_top (<span class="keyword">input</span> clk, reset);</span><br><span class="line">	<span class="comment">// Create an instance of the slave interface</span></span><br><span class="line">	slave_if 	slave_if_inst ( <span class="variable">.clk</span> (clk),</span><br><span class="line">	                            <span class="variable">.reset</span> (reset));</span><br><span class="line"></span><br><span class="line">	d_slave 	slave_0 (<span class="variable">.s_if</span> (slave_if_inst));</span><br><span class="line">	d_slave 	slave_1 (<span class="variable">.s_if</span> (slave_if_inst));</span><br><span class="line">	d_slave 	slave_2 (<span class="variable">.s_if</span> (slave_if_inst));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	现在，如果从接口中的某个信号发生了更改，该更改会自动应用到所有实例上。在 SystemVerilog 中，模块的端口列表也可以包含interface类型的端口，而不只是常规的<code>input</code>、<code>output</code>、<code>inout</code>端口。</p>
<p><strong>Interface Array</strong></p>
<p>在下面的示例中，创建了一个名为 <code>myInterface</code> 且端口列表为空的Interface，并在顶层测试平台模块中对其进行了实例化。对于空端口列表，也可以省略括号，直接用分号结束语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface myInterface;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> myInterface ();</span><br><span class="line">	<span class="keyword">reg</span> 		gnt;</span><br><span class="line">	<span class="keyword">reg</span> 		ack;</span><br><span class="line">	<span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>]	irq;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="comment">// Single interface handle</span></span><br><span class="line">    myInterface 	if0 (); <span class="comment">// 也可以这么例化 myInterface 	if0;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// An array of interfaces</span></span><br><span class="line">	myInterface 	wb_if [<span class="number">3</span>:<span class="number">0</span>] ();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Rest of the testbench</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	可以实例化一个名为 <code>if0</code> 的接口，要访问该接口内的信号，需要引用这个接口句柄。然后，就可以利用这个接口句柄来驱动发往DUT的信号，以及对这些信号进行采样。</p>
<p>​	也可以创建interface数组。在这里，这个数组名为 <code>wb_if</code>，它包含该interface的 4 个实例。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> myDesign ( myInterface dut_if,</span><br><span class="line">                  <span class="keyword">input</span> <span class="keyword">logic</span> clk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">		<span class="keyword">if</span> (dut_if<span class="variable">.ack</span>)</span><br><span class="line">			dut_if<span class="variable">.gnt</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Single interface handle connection</span></span><br><span class="line">	myInterface  if0;</span><br><span class="line">	myDesign 	 top (if0, clk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Or connect by name</span></span><br><span class="line">	<span class="comment">// myDesign  top (.dut_if(if0), .clk(clk));</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Multiple design instances connected to the appropriate</span></span><br><span class="line">	<span class="comment">// interface handle</span></span><br><span class="line">	myDesign 	md0 (wb_if[<span class="number">0</span>], clk);</span><br><span class="line">	myDesign 	md1 (wb_if[<span class="number">1</span>], clk);</span><br><span class="line">	myDesign 	md2 (wb_if[<span class="number">2</span>], clk);</span><br><span class="line">	myDesign 	md3 (wb_if[<span class="number">3</span>], clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	当一个interface作为端口被引用时，其中的变量和线网分别被假定具有引用（<code>ref</code>）和双向（<code>inout</code>）访问权限。如果在设计中使用相同的<strong>标识符</strong>作为<strong>接口实例名</strong>和<strong>端口名</strong>，那么也可以使用隐式端口连接。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line">	myInterface 	dut_if();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Can use implicit port connection when all port signals have same name</span></span><br><span class="line">	<span class="comment">// 隐式端口连接</span></span><br><span class="line">    myDesign 		top (.*);</span><br><span class="line">    <span class="comment">// 在SV中，.* 是一种特殊的隐式端口连接语法，它允许模块实例化时自动匹配同名的信号。</span></span><br><span class="line">    <span class="comment">// 使用 .* 表示自动匹配顶层模块 tb 中所有与 myDesign 模块端口名称相同的信号。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>.\*</code></strong>：表示自动匹配当前作用域中与模块端口名称相同的信号，并将它们连接起来。</p>
</li>
<li><p><strong>条件</strong>：要使用 <code>.*</code>，必须确保顶层模块中的信号名称与模块端口名称相同。</p>
</li>
<li><p><strong>接口实例名与端口名一致</strong>：当接口实例名和模块端口名一致时，可以使用 <code>.*</code> 进行隐式端口连接。</p>
</li>
</ul>
<p>注意！如果定义interface时没有<strong>端口</strong>且没有使用<strong>括号</strong>（即 <code>()</code>），则会发生错误。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare an interface without ports</span></span><br><span class="line"><span class="keyword">interface</span> mif;</span><br><span class="line">  <span class="keyword">logic</span> m_a;</span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  mif   m_if;      <span class="comment">// ERROR !</span></span><br><span class="line">  mif   m_if();    <span class="comment">// Okay</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="（三）Interface-bundles-接口捆绑"><a href="#（三）Interface-bundles-接口捆绑" class="headerlink" title="（三）Interface bundles(接口捆绑)"></a>（三）Interface bundles(接口捆绑)</h3><p>​	前面的介绍涵盖了使用接口的必要性，以及如何对接口进行实例化并将其与设计相连接。设计可以通过以下两种方式来编写：</p>
<ul>
<li><strong>使用现有接口名称</strong>：适用于需要强类型检查和明确接口类型的设计。这种方式确保了代码的类型安全性和可读性。</li>
<li><strong>使用通用接口句柄</strong>：适用于需要高度灵活性和动态接口配置的设计。这种方式允许传递任何类型的接口实例，但牺牲了类型检查的安全性。</li>
</ul>
<p>显然，当接口定义更新为名称不同的新版本，并且需要支持使用该接口的旧设计时，采用通用方法是最佳选择。</p>
<p><strong>Example using a named bundle</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> myDesign  (  myInterface  if0,</span><br><span class="line">                    <span class="keyword">input</span> <span class="keyword">logic</span>  clk);</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">		<span class="keyword">if</span> (if0<span class="variable">.ack</span>)</span><br><span class="line">			if0<span class="variable">.gnt</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> yourDesign (  myInterface 	if0,</span><br><span class="line">					 <span class="keyword">input</span> <span class="keyword">logic</span> 	clk);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	myInterface 	_if;</span><br><span class="line"></span><br><span class="line">	myDesign 	md0 	(_if, clk);</span><br><span class="line">	yourDesign	yd0 	(_if, clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>使用了固定的interface类型，即myInterface。</p>
<p><strong>Example using a generic bundle</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> myDesign  ( <span class="keyword">interface</span>  a,</span><br><span class="line">                   <span class="keyword">input</span> <span class="keyword">logic</span>  clk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk)</span><br><span class="line">		<span class="keyword">if</span> (if0<span class="variable">.ack</span>)</span><br><span class="line">			if0<span class="variable">.gnt</span> &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> yourDesign (  <span class="keyword">interface</span> 		b,</span><br><span class="line">					 <span class="keyword">input</span> <span class="keyword">logic</span> 	clk);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">logic</span> clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	myInterface  _if;</span><br><span class="line"></span><br><span class="line">	myDesign 	md0 ( .*, <span class="variable">.a</span>(_if));   <span class="comment">// use partial implicit port connections</span></span><br><span class="line">    yourDesign	yd0 ( .*, <span class="variable">.b</span>(_if));	  <span class="comment">// 使用部分隐式端口连接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>使用通用interface类型，即<strong>interface</strong>。</p>
<p><strong>隐式端口连接 (<code>.*</code>)</strong></p>
<ul>
<li><strong>隐式端口连接</strong>：当你使用 <code>.*</code> 时，编译器会自动匹配顶层模块中的信号名称与模块端口名称，并将它们连接起来。这要求顶层模块中的信号名称与模块端口名称完全一致。</li>
<li><code>.*</code> 将自动匹配并连接 <code>clk</code> 信号。</li>
</ul>
<p><strong>显式端口连接 (<code>.port_name(signal_name)</code>)</strong></p>
<ul>
<li><strong>显式端口连接</strong>：当你使用 <code>.port_name(signal_name)</code> 时，明确指定某个端口应该连接到哪个信号。这种方式适用于端口名称不一致的情况，或者你需要覆盖某些特定的端口连接。</li>
</ul>
<h3 id="（四）Modports"><a href="#（四）Modports" class="headerlink" title="（四）Modports"></a>（四）Modports</h3><p>​	在接口中会定义带有方向说明的 modport（模块端口）列表，以此对模块内部访问该接口的操作施加特定限制。关键字 <code>modport</code> 意味着这些方向的声明方式就好像是在模块内部进行声明的一样。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">modport</span>  [identifier]  (</span><br><span class="line">	<span class="keyword">input</span>  [port_list],</span><br><span class="line">	<span class="keyword">output</span> [port_list]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​	以下展示的是接口 <code>myInterface</code> 的定义，该接口包含几个信号以及两个 <code>modport</code> 声明。<code>modport dut0</code> 实际上规定了，对于使用这个特定 <code>modport</code> 的任何模块而言，信号 <code>ack</code> 和 <code>sel</code> 是输入信号，而 <code>gnt</code> 和 <code>irq0</code> 是输出信号。</p>
<p>类似地，还声明了另一个名为 <code>dut1</code> 的 <code>modport</code>，它规定了对于使用 <code>modport dut1</code> 的任何模块来说，<code>gnt</code> 和 <code>irq0</code> 是输入信号，另外两个信号是输出信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> 	myInterface;</span><br><span class="line">	<span class="keyword">logic</span> 	ack;</span><br><span class="line">	<span class="keyword">logic</span> 	gnt;</span><br><span class="line">	<span class="keyword">logic</span> 	sel;</span><br><span class="line">	<span class="keyword">logic</span> 	irq0;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ack and sel are inputs to the dut0, while gnt and irq0 are outputs</span></span><br><span class="line">	<span class="keyword">modport</span>  dut0 (</span><br><span class="line">		<span class="keyword">input</span> 	ack, sel,</span><br><span class="line">		<span class="keyword">output</span> 	gnt, irq0</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ack and sel are outputs from dut1, while gnt and irq0 are inputs</span></span><br><span class="line">	<span class="keyword">modport</span>  dut1 (</span><br><span class="line">		<span class="keyword">input</span> 	gnt, irq0,</span><br><span class="line">		<span class="keyword">output</span> 	ack, sel</span><br><span class="line">	);</span><br><span class="line"><span class="keyword">endinterface</span></span><br></pre></td></tr></table></figure>

<p>下面是两种不同的modport使用方式，一种在dut声明时指明，一种在连接时指明</p>
<p><strong>Example of named port bundle</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dut0  ( myinterface<span class="variable">.dut0</span>  _if);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dut1  ( myInterface<span class="variable">.dut1</span> _if);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	myInterface 	_if;</span><br><span class="line">	dut0  	d0 	( .* );</span><br><span class="line">	dut1 	d1 	( .* );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>Example of connecting port bundle</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dut0  ( myinterface  _if);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> dut1  ( myInterface _if);</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	myInterface 	_if;</span><br><span class="line">	dut0  	d0 	( <span class="variable">._if</span> (_if<span class="variable">.dut0</span>));</span><br><span class="line">	dut1 	d1 	( <span class="variable">._if</span> (_if<span class="variable">.dut1</span>));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="（五）Clocking-Blocks"><a href="#（五）Clocking-Blocks" class="headerlink" title="（五）Clocking Blocks"></a>（五）Clocking Blocks</h3><p>​	默认情况下，模块端口和interface不会指定信号之间的任何时序要求或同步方案。而在 <code>clocking</code> 和 <code>endclocking</code> 之间定义的时钟块（clocking block）就能做到这一点。时钟块是<strong>与特定时钟同步</strong>的一组信号的集合，它有助于指定时钟和信号之间的时序要求。</p>
<p>这能让测试编写人员更多地专注于事务处理，而不必担心信号相对于时钟何时进行交互。一个测试平台可以有多个时钟块，但每个时钟只能对应一个时钟块。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">default</span>] <span class="keyword">clocking</span> [identifier_name] @ [event_or_identifier]</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">input</span> #[delay_or_edge] <span class="keyword">output</span> #[delay_or_edge]</span><br><span class="line">	[list of signals]</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p>​	延迟值（<code>delay_value</code>）表示信号在相对于时钟事件的多少个时间单位的偏移处进行采样或驱动。如果未指定<code>default</code> skew(偏移)，那么所有输入信号将在指定事件发生后延迟 <code>#1step</code> 进行采样，而输出信号将在指定事件发生后延迟 <code>0ns</code> 进行驱动。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clocking</span> ckb @ (<span class="keyword">posedge</span> clk);</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">1</span>step <span class="keyword">output</span> <span class="keyword">negedge</span>;</span><br><span class="line">	<span class="keyword">input</span> ...;</span><br><span class="line">	<span class="keyword">output</span> ...;</span><br><span class="line"><span class="keyword">endclocking</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clocking</span> ck1 @ (<span class="keyword">posedge</span> clk);</span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">5</span>ns <span class="keyword">output</span> #<span class="number">2</span>ns;</span><br><span class="line">	<span class="keyword">input</span> data, valid, ready = top<span class="variable">.ele</span><span class="variable">.ready</span>;</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">negedge</span> grant;</span><br><span class="line">	<span class="keyword">input</span> #<span class="number">1</span>step addr;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p>请注意以下几点：</p>
<ul>
<li>创建了一个名为 <code>ck1</code> 的时钟块，该时钟块将在时钟信号 <code>clk</code> 的上升沿激活。</li>
<li>默认情况下，时钟块内的所有输入信号将在时钟 <code>clk</code> 上升沿前 5 纳秒进行采样，而时钟块内的所有输出信号将在时钟 <code>clk</code> 上升沿后 2 纳秒进行驱动。</li>
<li><code>data</code>、<code>valid</code> 和 <code>ready</code> 被声明为该时钟块的输入信号，因此它们将在时钟 <code>clk</code> 上升沿前 5 纳秒进行采样。</li>
<li><code>grant</code> 是该时钟块的一个输出信号，它有自己的时序要求。在这里，<code>grant</code> 将在时钟 <code>clk</code> 的下降沿进行驱动，而不是默认的上升沿。</li>
</ul>
<p>​	<strong>总结：</strong></p>
<p>​	简单来说，时钟块封装了一组共享同一个时钟的信号。因此，在接口内部声明时钟块有助于减少连接到Testbench所需的代码量，并且可能在开发过程中节省时间。</p>
<p>​	时钟块内的信号方向相对于<strong>Testbench</strong>而不是<strong>DUT</strong>。</p>
<h3 id="（六）CLocking-Blocks-II"><a href="#（六）CLocking-Blocks-II" class="headerlink" title="（六）CLocking Blocks II"></a>（六）CLocking Blocks II</h3><p>​	时钟块允许在指定的时钟事件发生时对输入信号进行采样，并驱动输出信号。如果为某个时钟块指定了<strong>输入偏移（skew）</strong>，那么该时钟块内的所有输入信号将在时钟事件发生前的<strong>指定偏移时间单位</strong>处进行采样。如果为某个时钟块指定了<strong>输出偏移</strong>，那么该时钟块内的所有输出信号将在相应时钟事件发生后的指定偏移时间单位处被驱动。</p>
<p><strong>什么是input skew和output skew？</strong></p>
<p>​	**偏移量（skew）**可指定为常量表达式或参数。如果仅使用一个数字，那么该偏移量将按照给定作用域内的有效时间单位来解释。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个名为 cb 的时钟块，用于描述该时钟块内的信号何时进行采样。</span></span><br><span class="line"><span class="keyword">clocking</span> cb @(clk);</span><br><span class="line">    <span class="keyword">input</span>  #<span class="number">1</span>ps req;</span><br><span class="line">    <span class="keyword">output</span> #<span class="number">2</span> 	gnt;</span><br><span class="line">    <span class="keyword">input</span>  #<span class="number">1</span> <span class="keyword">output</span> #<span class="number">3</span> sig;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p>​	 <code>req</code> 被指定了 1 ps的偏移量，它将在时钟信号 <code>clk</code> 的<strong>边沿到来前 1 ps</strong>进行采样。</p>
<p>​	 <code>gnt</code> 有 <strong>2 个时间单位</strong>的输出偏移量，因此它会遵循当前作用域内的时间单位。如果当前时间精度设置为 1 ns&#x2F;1 ps，那么 <code>#2</code> 代表 2 纳秒，<code>gnt</code> 信号将在时钟边沿到来后 2 纳秒被驱动。</p>
<p>​	<code>sig</code> 是双向（<code>inout</code>）类型的，它将在时钟边沿到来前 1 ns进行采样，并在时钟边沿到来后 3 ns被驱动。</p>
<p>​	1 个时间步长（<code>1step</code>）的输入偏移量表明，信号应在前一个时间步结束时进行采样，换句话说，就是在时钟上升沿到来的瞬间之前进行采样。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clocking</span> cb @(<span class="keyword">posedge</span> clk);</span><br><span class="line">	<span class="keyword">input</span> #<span class="number">1</span>step req;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>

<p>​	<strong><code>#1step</code></strong> 是 SystemVerilog 中的一个特殊时序控制符，表示相对于当前仿真时间步长的最小时间单位延迟。具体来说表示在当前仿真时间步长的下一个最小时间单位，这意味着它是在当前仿真时间步长内尽可能早地发生，但仍然晚于当前时间点。</p>
<p>​	带有显式 <code>#0</code> skew的输入信号将在与其对应的时钟事件发生的同一时刻进行采样，但会在 “观测（Observed）” 区域进行，以避免<strong>竞争</strong>条件。同样地，没有偏移量(skew)或者带有显式 <code>#0</code> 偏移量的输出信号将在时钟事件发生的<strong>同一时刻</strong>被驱动，不过是在 “重新调度非阻塞赋值（Re - NBA）” 区域进行。</p>
<p>​	<strong>clocking_skew</strong> 表示“一个信号被采样&#x2F;被驱动的<strong>时间点</strong>”距离当前的“<strong>时钟事件</strong>”有多少个<strong>单位时间</strong>。输入信号的 clocking_skew（称 input skew）表示输入信号被采样的时间点在“时钟事件”<strong>之前</strong>多少时间；</p>
<p>输出信号的 clocking_skew（称 output skew）表示输出信号被驱动的时间点在“时钟事件”<strong>之后</strong>多少时间。</p>
<p>默认的 input skew 为 <strong>1step</strong>，默认的 output skew 为 <strong>0</strong>。 step 是一个特殊的时间单位，不是一种物理时间单位。如果“时钟事件”不是一个数字，而是指定了一个边沿，那么 clocking_skew 也可以指定为信号的边沿。</p>
<p>可以通过 clocking 块的名称直接获取它的“时钟事件”，也就是说如有以下 clocking 块，<code>@(dram);</code>等价于 <code>@(posedge phi1);</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clocking</span> dram @(<span class="keyword">posedge</span> phi1);</span><br><span class="line">    <span class="keyword">inout</span> data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">negedge</span> #<span class="number">1</span> address;</span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure>



<h2 id="七、面向对象编程"><a href="#七、面向对象编程" class="headerlink" title="七、面向对象编程"></a>七、面向对象编程</h2><h3 id="（一）Class"><a href="#（一）Class" class="headerlink" title="（一）Class"></a>（一）Class</h3><p>Class是用户定义类型（user-defined data type），一种OOP构造，可用于封装data(property)和对数据进行操作的task&#x2F;function。这是一个例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> myPacket;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>]  header;</span><br><span class="line">	<span class="keyword">bit</span>        encode;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>]  mode;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]  data;</span><br><span class="line">	<span class="keyword">bit</span>        stop;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] header = <span class="number">3&#x27;h1</span>, <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] mode = <span class="number">5</span>);</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.header</span> = header;</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.encode</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.mode</span>   = mode;</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.stop</span>   = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> display ();</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;Header = 0x%0h, Encode = %0b, Mode = 0x%0h, Stop = %0b&quot;</span>,</span><br><span class="line">		           <span class="keyword">this</span><span class="variable">.header</span>, <span class="keyword">this</span><span class="variable">.encode</span>, <span class="keyword">this</span><span class="variable">.mode</span>, <span class="keyword">this</span><span class="variable">.stop</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>在上面的example中有一些关键的事情要注意：</p>
<ul>
<li>**function new()**称为构造函数，并在创建对象时自动调用。</li>
<li><strong>this</strong>关键字用于引用当前类。通常在类中用于引用自己的属性&#x2F;方法</li>
<li>**display()**是一个函数，这是很自然的，因为显示数值不需要消耗仿真时间</li>
<li>**function new()**对参数具有默认值，因此下面第6行将创建一个值为[3’h1,0,2’h3,1]的数据包对象</li>
</ul>
<p><strong>如何访问class中的信号？</strong></p>
<p>为了访问class中的信号，必须创建一个类的对象，该对象可以用作其属性和方法的<strong>句柄</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module tb_top;</span><br><span class="line">	myPacket pkt0, pkt1;</span><br><span class="line"></span><br><span class="line">	initial begin</span><br><span class="line">		pkt0 = new (3&#x27;h2, 2&#x27;h3);</span><br><span class="line">		pkt0.display ();</span><br><span class="line"></span><br><span class="line">		pkt1 = new ();</span><br><span class="line">		pkt1.display ();</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Header = 0x2, Encode = 0, Mode = 0x3, Stop = 1</span><br><span class="line">Header = 0x1, Encode = 0, Mode = 0x5, Stop = 1</span><br></pre></td></tr></table></figure>

<p><strong>如何创建一个类的数组？</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_top;</span><br><span class="line">	myPacket pkt0 [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">$size</span> (pkt0); i++) <span class="keyword">begin</span></span><br><span class="line">   	   		pkt0[i] = <span class="keyword">new</span> ();</span><br><span class="line">       		pkt0[i]<span class="variable">.display</span> ();</span><br><span class="line">   		<span class="keyword">end</span></span><br><span class="line">   	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Header = 0x1, Encode = 0, Mode = 0x5, Stop = 1</span><br><span class="line">Header = 0x1, Encode = 0, Mode = 0x5, Stop = 1</span><br><span class="line">Header = 0x1, Encode = 0, Mode = 0x5, Stop = 1</span><br></pre></td></tr></table></figure>

<p><strong>什么是继承(inheritance)？</strong></p>
<p>​	如果想拥有一个包含myPacket所有属性&#x2F;方法的类，并且能够在不更改myPacket的情况下在其中添加更多内容，最好的方法是通过继承(inheritance)。在下面的例子中，networkPacket使用扩展关键字<strong>extend</strong>继承了myPacket的属性和方法。要调用基类(myPacket)的函数，需要使用<strong>super</strong>关键字。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> networkPkt <span class="keyword">extends</span> myPacket;</span><br><span class="line">	<span class="keyword">bit</span>        parity;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>]  crc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.new</span> ();</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.parity</span> = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">this</span><span class="variable">.crc</span> = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> display ();</span><br><span class="line">		<span class="keyword">super</span><span class="variable">.display</span>();</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;Parity = %0b, CRC = 0x%0h&quot;</span>, <span class="keyword">this</span><span class="variable">.parity</span>, <span class="keyword">this</span><span class="variable">.crc</span>);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<p><strong>什么是abstract&#x2F;virtual class？</strong></p>
<p>​	如果使用<strong>virtual</strong>关键字创建抽象类，那么无法创建该类的对象。在不希望其他人创建该类的对象而是强制用户保留抽象类作为基类并继承它创建用于他们目的的子类时很有用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creation of base class object is invalid</span></span><br><span class="line"><span class="comment">// 创建基类的对象是无效的</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">class</span> Base;</span><br><span class="line">   <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]   data;</span><br><span class="line">   <span class="keyword">bit</span>         enable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Creation of child class object is valid</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Base;</span><br><span class="line">  <span class="comment">// User definition</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<h3 id="（二）Constructors构造函数"><a href="#（二）Constructors构造函数" class="headerlink" title="（二）Constructors构造函数"></a>（二）Constructors构造函数</h3><p>​	构造函数只是一种创建特定类数据类型的新对象的方法。即function new();</p>
<p>​	C&#x2F;C++ 需要复杂的内存分配技术，而且不恰当的内存释放可能会导致内存泄漏和其他行为问题。虽然 SystemVerilog 并非编程语言，但它能够轻松地创建对象，并且具备自动垃圾回收功能。</p>
<p><strong>显式定义类的构造函数</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">    addr = <span class="number">32&#x27;hfade_cafe</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>隐式定义类的构造函数</strong></p>
<p>​	如果类没有显式编码的<code>new()</code>函数，则会自动提供隐式<code>new()</code>方法。在这种情况下，addr被初始化为零，因为它是默认值为0的bit类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a simple class with a variable called &quot;addr&quot;</span></span><br><span class="line"><span class="comment">// Note that the new() function is not defined here</span></span><br><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="comment">// 当类对象被实例化时，构造函数会由工具隐式定义并调用。</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		Packet pkt = <span class="keyword">new</span>;</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;addr=0x%0h&quot;</span>, pkt<span class="variable">.addr</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数不能声明为static或virtual。</strong></p>
<p>构造函数可以声明为<code>local</code>或<code>protect</code>，但不能声明为<code>static</code>或<code>virtual</code>.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">string</span> fruit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new() 不能被定义为virtual和static</span></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">    fruit = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<h3 id="（三）This关键字"><a href="#（三）This关键字" class="headerlink" title="（三）This关键字"></a>（三）This关键字</h3><p>​	<code>This</code>关键字用于引用当前实例的类属性、参数和方法。它只能在非静态方法、约束和覆盖组中使用。这基本上是一个预定义的对象句柄，指的是用来调用使用this的方法的对象。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr);</span><br><span class="line"><span class="comment">//		addr = addr;          //  Which addr should get assigned ?</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span><span class="variable">.addr</span> = addr;     <span class="comment">//  addr variable in Packet class should be</span></span><br><span class="line">		                      <span class="comment">//  assigned with local variable addr in new()</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>除非赋值存在歧义，否则在方法中指定对类成员的访问通常不需要使用此关键字。</p>
<h3 id="（四）Polymorphism多态"><a href="#（四）Polymorphism多态" class="headerlink" title="（四）Polymorphism多态"></a>（四）Polymorphism多态</h3><p>​	在SystemVerilog中，<strong>多态性（Polymorphism）</strong> 是面向对象编程（OOP）中的一个核心概念，它允许你使用统一的接口来处理不同类型的对象。具体来说，多态性使得同一个方法调用可以在不同的对象上表现出不同的行为，这取决于实际的对象类型。	</p>
<p>​	多态性允许使用基类类型的变量来存储子类对象，并直接从基类变量引用那些子类的方法。如果父类中的方法本质上是虚方法，那么它还允许子类中的方法拥有与父类方法不同的定义。</p>
<p><strong>Parent and Child Assignment</strong></p>
<p>​	<code>class handle</code>只是一个用于存放父类或子类对象的容器。在 SystemVerilog 中，理解父类句柄存放子类对象以及子类句柄存放父类对象时的行为表现是非常重要的。</p>
<p><strong>Assign Child Class to Base Class</strong>子类对象赋值给基类句柄</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	Packet      bc; 	<span class="comment">// bc stands for BaseClass</span></span><br><span class="line">	ExtPacket   sc; 	<span class="comment">// sc stands for SubClass</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		sc = <span class="keyword">new</span> (<span class="number">32&#x27;hfeed_feed</span>, <span class="number">32&#x27;h1234_5678</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Assign sub-class to base-class handle</span></span><br><span class="line">		bc = sc;</span><br><span class="line"></span><br><span class="line">		bc<span class="variable">.display</span> ();</span><br><span class="line">		sc<span class="variable">.display</span> ();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">[Base] addr=0xfeedfeed</span><br><span class="line">[Child] addr=0xfeedfeed data=0x12345678</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>

<p>​	即使bc指向子类实例，当从bc调用display（）函数时，它仍然调用<strong>基类中的display（）<strong>函数。这是因为该函数是根据</strong>句柄的类型</strong>而不是<strong>句柄指向的对象类型</strong>调用的。现在让我们尝试通过基类句柄引用子类成员，您会收到编译错误。</p>
<blockquote>
<p>如果父类和子类的函数同名，通过句柄调用函数，跟句柄类型有关，在声明时定义</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	Packet      bc; 	<span class="comment">// bc stands for BaseClass</span></span><br><span class="line">	ExtPacket   sc; 	<span class="comment">// sc stands for SubClass</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		sc = <span class="keyword">new</span> (<span class="number">32&#x27;hfeed_feed</span>, <span class="number">32&#x27;h1234_5678</span>);</span><br><span class="line">		bc = sc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print variable in sub-class that is pointed to by</span></span><br><span class="line">        <span class="comment">// base class handle</span></span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;data=0x%0h&quot;</span>, bc<span class="variable">.data</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<p>**Assign Base Class to Child Class **基类对象赋值给子类句柄</p>
<p>​	直接将一个基类类型的变量赋值给其某个子类类型的变量是不合法的，会得到一个编译错误。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		bc = <span class="keyword">new</span> (<span class="number">32&#x27;hface_cafe</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign base class object to sub-class handle</span></span><br><span class="line">		sc = bc;</span><br><span class="line"></span><br><span class="line">		bc<span class="variable">.display</span> ();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>然而，<code>$cast</code>可以用于将一个超类句柄赋值给子类类型的变量，前提是该超类句柄引用的对象与子类变量是赋值兼容的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">		bc = <span class="keyword">new</span> (<span class="number">32&#x27;hface_cafe</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dynamic cast base class object to sub-class type</span></span><br><span class="line">        <span class="comment">// 将基类对象动态转换为子类类型</span></span><br><span class="line">		<span class="built_in">$cast</span> (sc, bc);</span><br><span class="line"></span><br><span class="line">		bc<span class="variable">.display</span> ();</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	尽管代码可以顺利编译，但由于<code>$cast</code>的失败，它会在运行时产生仿真错误。这是因为<code>bc</code>并没有指向一个与<code>sc</code>兼容的对象。</p>
<blockquote>
<p>在SystemVerilog中，<code>$cast</code>是一个系统函数，用于安全地进行类型转换。它主要用于处理类（class）之间的类型转换，特别是当涉及到继承关系时（即超类和子类之间）。以下是更详细的解释：</p>
<ul>
<li><strong>超类（Superclass）</strong>：这是指定义了通用行为或属性的基类。</li>
<li><strong>子类（Subclass）</strong>：这是从超类派生出来的类，可能包含额外的功能或覆盖超类的行为。</li>
<li><strong>类型兼容性</strong>：在SystemVerilog中，只有当对象的实际类型与目标类型相同或目标类型是实际类型的派生类时，<code>$cast</code>才会成功。在这个例子中，<code>SubClass2</code>和<code>SubClass1</code>没有继承关系，因此转换失败。</li>
</ul>
</blockquote>
<p><strong>赋值兼容性的具体规则</strong></p>
<p><strong>向上转型（Upcasting）</strong>：将子类对象赋值给超类句柄是安全的，因为子类对象包含所有超类的成员和方法.</p>
<p><strong>向下转型（Downcasting）</strong>：将超类对象赋值给子类句柄需要类型转换（如<code>$cast</code>），并且只有在超类句柄实际指向的是一个子类对象时才会成功。</p>
<p><strong>Virtual Method</strong></p>
<p>​	父类中的方法可以被声明为<code>Virtual Method</code>，这将允许所有子类使用不同的定义来重写该方法，但包含返回类型和参数的方法原型必须保持不变。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Parent class has a method called &#x27;display&#x27; declared as virtual</span></span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">string</span> tag=<span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;[Base] %s: addr=0x%0h data=0x%0h&quot;</span>, tag, addr, data);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Base;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> en;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Child class redefines the method to also print &#x27;en&#x27; variable</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">void</span> display(<span class="keyword">string</span> tag=<span class="string">&quot;Thread1&quot;</span>);</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;[Child] %s: addr=0x%0h data=0x%0h en=%0d&quot;</span>, tag, addr, data, en);</span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>规则</strong></p>
<ul>
<li><p><strong>允许将派生类句柄分配给基类句柄</strong></p>
</li>
<li><p><strong>不允许将基类句柄分配给派生类句柄，这会导致编译错误</strong></p>
</li>
</ul>
<p>​	如果类型转换失败，<code>$cast</code> 函数会返回 0，因此可以利用其返回值来抛出错误。可以使用 <code>if</code> 语句或者 <code>assert</code> 语句来确保类型转换成功。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">base 	b = <span class="keyword">new</span>;</span><br><span class="line">child 	c = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (! <span class="built_in">$cast</span>(c, b))</span><br><span class="line">	<span class="built_in">$error</span>(<span class="string">&quot;Cast failed !&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">$cast</span>(c, b)) <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">$error</span>(<span class="string">&quot;Cast failed !&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="（五）虚方法virtual-method"><a href="#（五）虚方法virtual-method" class="headerlink" title="（五）虚方法virtual method"></a>（五）虚方法virtual method</h3><p>​	在SystemVerilog中，类的虚方法（virtual method）主要用于实现<strong>多态性</strong>，这是面向对象编程（OOP）中的一个重要概念。虚方法允许子类重写父类中的方法，并且通过父类类型的句柄调用方法时，实际执行的是子类中重写的版本。这种设计使得代码更加灵活、可扩展和易于维护</p>
<p><strong>虚方法的主要作用</strong></p>
<ol>
<li><strong>实现多态性</strong>：<ul>
<li>多态性是指同一个接口可以有不同的实现方式。通过虚方法，可以在父类中定义一个通用的方法接口，而具体的实现则由各个子类提供。</li>
<li>这样做的好处是，你可以编写通用的代码来处理不同类型的对象，而不需要知道它们的具体类型。</li>
</ul>
</li>
<li><strong>动态绑定（Dynamic Binding）</strong>：<ul>
<li>在运行时根据对象的实际类型决定调用哪个方法版本。这与静态绑定（编译时绑定）形成对比，静态绑定是在编译时就确定了调用哪个方法。</li>
<li>动态绑定使得程序在运行时更具灵活性，能够根据对象的实际类型调用相应的方法。</li>
</ul>
</li>
<li><strong>提高代码复用性和扩展性</strong>：<ul>
<li>通过使用虚方法，你可以在不修改现有代码的情况下添加新的子类和新的行为。这使得系统更容易扩展和维护。</li>
</ul>
</li>
</ol>
<p><strong>设计原因</strong></p>
<p>虚方法的设计是为了支持面向对象编程的核心原则之一——<strong>开闭原则</strong>（Open&#x2F;Closed Principle）。该原则指出，软件实体（类、模块、函数等）应该<strong>对扩展开放，对修改封闭</strong>。具体来说：</p>
<ul>
<li><strong>对扩展开放</strong>：可以通过添加新的子类来扩展功能，而不需要修改现有的代码。</li>
<li><strong>对修改封闭</strong>：现有的代码不应该因为新功能的添加而频繁修改。</li>
</ul>
<h3 id="（六）静态变量或函数Static-Variables-Function"><a href="#（六）静态变量或函数Static-Variables-Function" class="headerlink" title="（六）静态变量或函数Static Variables &amp; Function"></a>（六）静态变量或函数Static Variables &amp; Function</h3><p>通常情况下，每个类实例都会拥有其内部每个变量的一个副本。</p>
<h4 id="1、Static-Variables静态变量"><a href="#1、Static-Variables静态变量" class="headerlink" title="1、Static Variables静态变量"></a><strong>1、Static Variables静态变量</strong></h4><p><strong>定义</strong></p>
<p>静态变量是属于类本身的成员变量，而不是属于类的某个具体实例。这意味着所有类的实例共享同一个静态变量。静态变量在类的所有对象之间共享，并且在整个仿真过程中保持其值，除非显式地修改它。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>生命周期</strong>：静态变量在程序启动时创建，在程序结束时销毁。它们的生命周期独立于任何类实例。</li>
<li><strong>作用范围</strong>：静态变量可以被类的所有实例访问，也可以通过类名直接访问。</li>
<li><strong>初始化</strong>：静态变量可以在声明时初始化，或者在静态构造函数（static initial block）中初始化。</li>
</ul>
<h4 id="2、Static-function静态函数"><a href="#2、Static-function静态函数" class="headerlink" title="2、Static function静态函数"></a><strong>2、Static function静态函数</strong></h4><p><strong>定义</strong></p>
<p>静态函数是属于类本身的成员函数，而不是属于类的某个具体实例。静态函数不能访问类的非静态成员（即实例变量和实例方法），但可以访问其他静态成员。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>调用方式</strong>：静态函数可以通过类名直接调用，而不需要创建类的实例。</li>
<li><strong>作用范围</strong>：静态函数可以访问类的静态变量和其他静态函数，但不能访问实例变量或实例方法。</li>
<li><strong>用途</strong>：静态函数通常用于实现与类相关的操作，这些操作不依赖于类的具体实例。</li>
<li>**注意：**静态方法不能是虚方法。使用类名调用静态函数时，需要通过作用域操作符 <code>::</code> 来进行调用。</li>
</ul>
<h4 id="3、静态变量和静态函数的区别"><a href="#3、静态变量和静态函数的区别" class="headerlink" title="3、静态变量和静态函数的区别"></a>3、静态变量和静态函数的区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>静态变量（Static Variable）</th>
<th>静态函数（Static Function）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>生命周期</strong></td>
<td>在整个仿真过程中存在，直到仿真结束</td>
<td>在整个仿真过程中存在，直到仿真结束</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>类的所有实例共享，也可以通过类名直接访问</td>
<td>可以通过类名直接调用，不需要创建类的实例</td>
</tr>
<tr>
<td><strong>访问实例成员</strong></td>
<td>不允许直接访问实例变量和实例方法</td>
<td>不允许访问实例变量和实例方法</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td>可以通过类名或实例访问</td>
<td>只能通过类名调用</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>可以在声明时初始化，也可以在静态构造块中初始化</td>
<td>可以在类定义中实现</td>
</tr>
</tbody></table>
<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><ul>
<li><strong>静态变量</strong>：属于类本身，所有实例共享，生命周期从仿真开始到结束。</li>
<li><strong>静态函数</strong>：属于类本身，只能访问静态成员，不能访问实例成员，可以通过类名直接调用。</li>
</ul>
<h3 id="（七）深拷贝与浅拷贝Shallow-Deep-Copy"><a href="#（七）深拷贝与浅拷贝Shallow-Deep-Copy" class="headerlink" title="（七）深拷贝与浅拷贝Shallow&#x2F;Deep Copy"></a>（七）深拷贝与浅拷贝Shallow&#x2F;Deep Copy</h3><p>​	在SV中，<strong>深拷贝（Deep Copy）</strong> 和 <strong>浅拷贝（Shallow Copy）</strong> 是两种不同的对象复制方式。它们的主要区别在于如何处理对象中的成员变量，特别是当这些成员变量是对象引用时。</p>
<h4 id="1、浅拷贝（Shallow-Copy）"><a href="#1、浅拷贝（Shallow-Copy）" class="headerlink" title="1、浅拷贝（Shallow Copy）"></a><strong>1、浅拷贝（Shallow Copy）</strong></h4><p><strong>浅拷贝</strong>是指创建一个新的对象，并将原始对象的<strong>非静态字段</strong>复制到新对象中。如果字段是基本数据类型，则直接复制其值；如果是对象引用，则只复制引用本身，而不复制引用的对象。因此，两个对象将共享相同的引用对象。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>基本数据类型的字段</strong>：直接复制其值。</li>
<li><strong>对象引用字段</strong>：只复制引用，不复制引用的对象，因此两个对象共享相同的引用对象。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Packet pkt, pkt2;</span><br><span class="line"></span><br><span class="line">pkt = <span class="keyword">new</span>;</span><br><span class="line">pkt2 = <span class="keyword">new</span> pkt;</span><br></pre></td></tr></table></figure>

<h4 id="2、深拷贝（Deep-Copy）"><a href="#2、深拷贝（Deep-Copy）" class="headerlink" title="2、深拷贝（Deep Copy）"></a><strong>2、深拷贝（Deep Copy）</strong></h4><p><strong>深拷贝</strong>是指创建一个新的对象，并递归地复制原始对象及其所有嵌套对象的所有字段。这意味着不仅基本数据类型的字段会被复制，对象引用字段也会被复制为新的对象实例，为此通常需要自定义代码。</p>
<h4 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a><strong>3、特点</strong></h4><ul>
<li><strong>基本数据类型的字段</strong>：直接复制其值。</li>
<li><strong>对象引用字段</strong>：递归地复制引用的对象，生成新的对象实例，因此两个对象不会共享相同的引用对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Packet p1 = new;</span><br><span class="line">Packet p2 = new;</span><br><span class="line">p2.copy (p1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Packet;</span><br><span class="line">	...</span><br><span class="line">   function copy (Packet p);</span><br><span class="line">      this.addr = p.addr;</span><br><span class="line">      this.data = p.data;</span><br><span class="line">      this.hdr.id = p.hdr.id;</span><br><span class="line">   endfunction</span><br><span class="line">	...</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>

<h4 id="4、总结-1"><a href="#4、总结-1" class="headerlink" title="4、总结"></a><strong>4、总结</strong></h4><ul>
<li><strong>浅拷贝</strong>：只复制对象的基本数据类型字段和对象引用，但不复制引用的对象。多个对象共享相同的引用对象。</li>
<li><strong>深拷贝</strong>：递归地复制对象及其所有嵌套对象的所有字段，生成完全独立的对象副本。</li>
</ul>
<h3 id="（八）参数化类（Parameterized-Classes）"><a href="#（八）参数化类（Parameterized-Classes）" class="headerlink" title="（八）参数化类（Parameterized Classes）"></a>（八）参数化类（Parameterized Classes）</h3><p>参数化类通过在类定义中引入参数来实现灵活性。这些参数可以在类声明时指定，也可以在类实例化时传递具体的值。参数化类的主要用途包括：</p>
<ul>
<li><strong>类型参数化</strong>：允许类成员的类型根据需要变化。</li>
<li><strong>数值参数化</strong>：允许类成员的大小或其他属性根据需要变化。</li>
<li><strong>提高代码复用性</strong>：通过一次定义一个通用的类模板，可以根据不同的参数创建多个特定的类实例。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare parameterized class</span></span><br><span class="line"><span class="keyword">class</span> &lt;name_of_class&gt; <span class="variable">#(&lt;parameters&gt;)</span>;</span><br><span class="line"><span class="keyword">class</span> Trans <span class="variable">#(addr = 32)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Override class parameter</span></span><br><span class="line">&lt;name_of_class&gt;  <span class="variable">#(&lt;parameters&gt;)</span> &lt;name_of_inst&gt;;</span><br><span class="line">Trans <span class="variable">#(.addr(16))</span> obj;</span><br></pre></td></tr></table></figure>

<p><strong>传递datatype作为参数</strong></p>
<p>在这种情况下，Data-type是参数化的，并且可以在实例化时进行覆盖。在之前的情况中，我们定义参数以使其具有特定的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;T&quot; is a parameter that is set to have a default value of &quot;int&quot;</span></span><br><span class="line"><span class="comment">// Hence &quot;items&quot; will be &quot;int&quot; by default</span></span><br><span class="line"><span class="keyword">class</span> stack <span class="variable">#(type T = int)</span>;</span><br><span class="line">  T item;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> T add_a (T a);</span><br><span class="line">    <span class="keyword">return</span> item + a;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<h3 id="（九）local标识符"><a href="#（九）local标识符" class="headerlink" title="（九）local标识符"></a>（九）local标识符</h3><p>​	在SystemVerilog中，<code>local</code> 关键字用于限制类成员的可见性和访问范围。具体来说，<code>local</code> 修饰符用于声明类中的局部变量或方法，使得这些成员只能在定义它们的类内部访问，而不能从类外部或其他派生类中访问。这有助于封装和保护类的内部实现细节。</p>
<p><strong><code>local</code> 关键字的主要用途</strong></p>
<ol>
<li><strong>增强封装性</strong>：<ul>
<li>使用 <code>local</code> 修饰符可以隐藏类的内部实现细节，防止外部代码直接访问这些成员，从而提高类的安全性和可维护性。</li>
</ul>
</li>
<li><strong>防止误用</strong>：<ul>
<li>通过限制对某些成员的访问，可以防止外部代码错误地修改类的状态，确保类的行为符合预期。</li>
</ul>
</li>
<li><strong>支持模块化设计</strong>：<ul>
<li>将类的内部实现细节隐藏起来，使类的设计更加模块化和易于扩展。</li>
</ul>
</li>
</ol>
<p><strong><code>local</code> 的使用场景</strong></p>
<ul>
<li><strong>局部变量</strong>：使用 <code>local</code> 声明的变量只能在定义它们的类内部访问。</li>
<li><strong>局部方法</strong>：使用 <code>local</code> 声明的方法只能在定义它们的类内部调用，不能从类外部或其他派生类中调用。</li>
</ul>
<p><strong><code>local</code> 与 <code>protected</code> 和 <code>public</code> 的比较</strong></p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>访问权限</th>
</tr>
</thead>
<tbody><tr>
<td><code>local</code></td>
<td>仅限于定义它的类内部访问</td>
</tr>
<tr>
<td><code>protected</code></td>
<td>仅限于定义它的类及其派生类访问</td>
</tr>
<tr>
<td><code>public</code></td>
<td>允许所有地方访问</td>
</tr>
</tbody></table>
<ul>
<li><strong><code>local</code></strong>：最严格的访问控制，只能在定义它的类内部访问。</li>
<li><strong><code>protected</code></strong>：允许在定义它的类及其派生类中访问，但不允许从类外部访问。</li>
<li><strong><code>public</code></strong>：默认访问级别，允许从任何地方访问。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong><code>local</code></strong> 关键字用于限制类成员（变量或方法）的可见性和访问范围，使其只能在定义它们的类内部访问。</li>
<li>使用 <strong><code>local</code></strong> 可以增强类的封装性，防止外部代码直接访问或修改类的内部状态，从而提高代码的安全性和可维护性。</li>
<li><strong><code>local</code></strong> 成员与 <strong><code>protected</code></strong> 和 <strong><code>public</code></strong> 成员相比，具有最严格的访问控制，适用于需要严格保护的内部实现细节。</li>
</ul>
<h3 id="（十）抽象类（Abstract-class）"><a href="#（十）抽象类（Abstract-class）" class="headerlink" title="（十）抽象类（Abstract class）"></a>（十）抽象类（Abstract class）</h3><p>​	在SystemVerilog中，<strong>抽象类（Abstract Class）</strong> 是一种特殊的类，它不能被实例化，通常用于定义一个<strong>通用接口</strong>或<strong>模板</strong>，供其他具体类继承和实现。抽象类可以包含<strong>抽象方法</strong>（没有实现的方法）和<strong>具体的成员</strong>（有实现的方法、变量等）。通过使用抽象类，你可以强制子类实现某些特定的行为，从而确保系统的一致性和可扩展性。</p>
<p><strong>抽象类的主要特点</strong></p>
<ol>
<li><p><strong>不能实例化</strong>：</p>
<p>抽象类不能直接创建实例，必须由具体的子类继承并实现其抽象方法后才能实例化。</p>
</li>
<li><p><strong>包含抽象方法</strong>：</p>
<p>抽象类可以包含抽象方法（即没有具体实现的方法），这些方法必须由子类实现。</p>
</li>
<li><p><strong>可以包含具体成员</strong>：</p>
<p>除了抽象方法外，抽象类还可以包含具体的成员（如方法、变量等），这些成员可以直接使用，不需要子类重新实现。</p>
</li>
<li><p><strong>支持多态性</strong>：</p>
<p>抽象类支持多态性，允许通过基类类型的句柄来引用子类对象，从而实现运行时动态绑定。</p>
</li>
</ol>
<p><strong>定义抽象类</strong></p>
<p>在SystemVerilog中，使用 <code>virtual</code> 关键字声明一个类为抽象类，并使用 <code>pure virtual</code> 方法定义抽象方法。抽象方法没有具体实现，只提供方法签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">virtual class Shape; // 抽象类</span><br><span class="line">    pure virtual function void draw(); // 抽象方法</span><br><span class="line">    pure virtual function real area(); // 抽象方法</span><br><span class="line"></span><br><span class="line">    // 具体方法</span><br><span class="line">    function void display();</span><br><span class="line">        $display(&quot;This is a shape&quot;);</span><br><span class="line">    endfunction</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>



<p><strong>实现抽象类</strong></p>
<p>为了使用抽象类，必须定义具体的子类，并实现所有的抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Circle extends Shape;</span><br><span class="line">    real radius;</span><br><span class="line"></span><br><span class="line">    function new(real r);</span><br><span class="line">        radius = r;</span><br><span class="line">    endfunction</span><br><span class="line"></span><br><span class="line">    // 实现抽象方法 draw()</span><br><span class="line">    virtual function void draw();</span><br><span class="line">        $display(&quot;Drawing a circle with radius %0f&quot;, radius);</span><br><span class="line">    endfunction</span><br><span class="line"></span><br><span class="line">    // 实现抽象方法 area()</span><br><span class="line">    virtual function real area();</span><br><span class="line">        return 3.14159 * radius * radius;</span><br><span class="line">    endfunction</span><br><span class="line">endclass</span><br></pre></td></tr></table></figure>

<p><strong>使用抽象类</strong></p>
<p>​	由于抽象类不能直接实例化，你必须通过具体的子类来创建对象，并可以通过基类类型的句柄引用这些对象。</p>
<p><strong>抽象类的优势</strong></p>
<ol>
<li><p><strong>强制实现</strong>：</p>
<p>抽象类可以强制子类实现某些特定的方法，确保所有派生类都具有相同的行为接口。</p>
</li>
<li><p><strong>提高代码复用性</strong>：</p>
<p>抽象类可以包含一些公共的实现，供所有子类共享，减少重复代码。</p>
</li>
<li><p><strong>支持多态性</strong>：</p>
<p>抽象类支持多态性，使得可以通过<strong>基类类型的句柄</strong>来引用子类对象，从而实现运行时动态绑定。</p>
</li>
</ol>
<h2 id="八、约束（Constraints）"><a href="#八、约束（Constraints）" class="headerlink" title="八、约束（Constraints）"></a>八、约束（Constraints）</h2><p><strong>什么是直接测试（direct tests）？</strong></p>
<p>​	验证工程师将首先创建一个称为<strong>验证计划</strong>的东西，详细说明RTL仿真中需要测试的设计的每个功能，以及每个测试将如何创建针对特定功能的独立场景。</p>
<p>例如，如果有一个外设需要配置其寄存器以启动AXI总线事务，那么我们将进行不同的测试来以不同的方式配置这些寄存器并实现良好的覆盖。</p>
<p>这些是直接测试，其中每个测试执行特定任务来完成某事。</p>
<p><strong>什么是随机测试（randomized tests）？</strong></p>
<p>​	复杂的设计有很多场景和许多极端情况，这些场景和极端情况可以通过随机测试更好地验证，并且花费的精力和时间要少得多。以上面的相同示例为例，每次使用不同的种子运行测试时，测试都会使用随机值配置外围寄存器，从而为每次运行实现不同的场景。这将确保我们遇到极端情况并发现任何隐藏的错误。</p>
<p>​	SystemVerilog允许用户以紧凑的声明性方式指定约束，然后由内部求解器处理以生成满足所有条件的<strong>随机值</strong>。基本上，约束只不过是一种让我们定义应该为随机变量分配哪些合法值的方法。一个普通变量被关键字<strong>rand</strong>声明为random。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pkt;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constraint</span> addr_limit &#123; addr &lt;= <span class="number">8&#x27;hB</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p>​	上面的例子声明了一个名为Pkt的类，对其<strong>地址字段</strong>有一个约束。请注意，它的两个属性都以rand关键字为前缀，该关键字告诉求解器这些变量应该在被要求时随机化。该约束称为<strong>addr_limit</strong>，并指定求解器可以为地址分配任何低于或等于8’h8的随机值。由于8位变量addr是bit类型，它可以具有0到255之间的任何值，但有了约束，有效值将被限制为11。</p>
<p>​	这个强大的功能将允许我们创建约束在对设计有效的范围内的变量，并将产生更好的验证效果。</p>
<h3 id="（一）随机变量（Random-variable）"><a href="#（一）随机变量（Random-variable）" class="headerlink" title="（一）随机变量（Random variable）"></a>（一）随机变量（Random variable）</h3><p>变量使用<code>rand</code>或<code>randc</code>关键字声明为随机。它们可用于普通变量、数组、动态数组或队列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Packet;</span><br><span class="line">	rand bit [2:0] data;</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module tb;</span><br><span class="line">	initial begin</span><br><span class="line">		Packet pkt = new ();</span><br><span class="line">		for (int i = 0 ; i &lt; 10; i++) begin</span><br><span class="line">            // 	函数randomize()作为类对象的一部分被调用，以随机化该类对象中的所有rand类型变量。</span><br><span class="line">			pkt.randomize ();</span><br><span class="line">			$display (&quot;itr=%0d data=0x%0h&quot;, i, pkt.data);</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<p><code>randc</code> 用于声明一个<strong>随机循环变量</strong>。与普通的随机变量（使用 <code>rand</code> 声明）不同，<code>randc</code> 变量在生成随机值时会保证所有可能的值都被遍历一次，才会开始重复之前的值，即它会以循环的方式生成所有可能的随机值组合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Packet;</span><br><span class="line">	randc bit [2:0] data;</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module tb;</span><br><span class="line">	initial begin</span><br><span class="line">		Packet pkt = new ();</span><br><span class="line">		for (int i = 0 ; i &lt; 10; i++) begin</span><br><span class="line">			pkt.randomize ();</span><br><span class="line">			$display (&quot;itr=%0d data=0x%0h&quot;, i, pkt.data);</span><br><span class="line">		end</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>



<h3 id="（二）约束块（Constraint-block）"><a href="#（二）约束块（Constraint-block）" class="headerlink" title="（二）约束块（Constraint block）"></a>（二）约束块（Constraint block）</h3><p>​	<strong>约束块</strong>是<strong>类成员</strong>，就像变量、函数和任务一样。它们在类中具有唯一的名称。这些表达式块通常用于将随机变量的值限制在约束块中指定的某些值内。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span>  [name_of_constraint] &#123;  [expression <span class="number">1</span>];</span><br><span class="line">                                    [expression N]; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、表达式的定义</strong>：</p>
<ul>
<li>花括号 <code>&#123;&#125;</code> 内的表达式定义了求解器在生成随机值时必须遵循的条件。这些条件可以涉及一个或多个变量，并且可以是简单的比较运算、复杂的逻辑关系或内置函数调用。</li>
</ul>
<p><strong>2、约束块的灵活性</strong>：</p>
<ul>
<li><strong>不需要为每个变量都设置单独的约束</strong>：你可以将多个变量的约束条件放在同一个约束块内。例如，可以在一个约束块中同时定义 <code>x</code> 和 <code>y</code> 的取值范围。</li>
<li><strong>约束块不必局限于单个变量</strong>：一个约束块可以包含涉及多个变量的条件。例如，可以定义 <code>x &gt; y</code> 这样的条件，它涉及到两个变量的关系。</li>
</ul>
<p><strong>3、避免冲突的约束</strong>：</p>
<ul>
<li><strong>不能有相互冲突的约束</strong>：如果在不同的约束块中定义了相互冲突的约束条件（例如，在一个约束块中定义 <code>x &gt; y</code>，而在另一个约束块中定义 <code>y &gt; x</code>），求解器将无法找到满足所有条件的解决方案，从而导致随机化失败。</li>
<li><strong>可以通过 <code>constraint_mode()</code> 方法禁用冲突的约束</strong>：如果你确实需要在某些情况下忽略某些约束，可以使用 <code>constraint_mode()</code> 方法来动态启用或禁用特定的约束块。这样可以在运行时根据需要调整约束条件，以避免冲突。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 单一约束块，涉及多个变量</span><br><span class="line">constraint combined_c &#123;</span><br><span class="line">    x &gt; 0 &amp;&amp; x &lt; 100; // x 的取值范围为 (0, 100)</span><br><span class="line">    y == x + 10;      // y 的值等于 x + 10</span><br><span class="line">&#125;</span><br><span class="line">// 第一个约束块</span><br><span class="line">constraint c1 &#123;</span><br><span class="line">    x &gt; 0 &amp;&amp; x &lt; 100; // x 的取值范围为 (0, 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二个约束块</span><br><span class="line">constraint c2 &#123;</span><br><span class="line">    y == x + 10; // y 的值等于 x + 10</span><br><span class="line">&#125;</span><br><span class="line">// 禁用冲突的约束块</span><br><span class="line">obj.c2.constraint_mode(0); // 禁用 c2 约束</span><br></pre></td></tr></table></figure>

<p>空约束对随机化没有影响！</p>
<h3 id="（三）数组随机化（Array-Randomization）"><a href="#（三）数组随机化（Array-Randomization）" class="headerlink" title="（三）数组随机化（Array Randomization）"></a>（三）数组随机化（Array Randomization）</h3><p>​	SystemVerilog随机化也适用于<strong>静态数组</strong>、<strong>动态数组</strong>和<strong>队列</strong>等数组数据结构。必须使用<code>rand</code>或<code>randc</code>类型声明变量以启用变量的随机化。</p>
<p><strong>1、Static Array</strong></p>
<p>静态数组的随机化是直接的，可以类似于任何其他类型的SystemVerilog变量来完成。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] 	s_array [<span class="number">7</span>]; 	<span class="comment">// Declare a static array with &quot;rand&quot;</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  Packet pkt;</span><br><span class="line">  <span class="comment">// Create a new packet, randomize it and display contents</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    pkt = <span class="keyword">new</span>();</span><br><span class="line">    pkt<span class="variable">.randomize</span>();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;queue = %p&quot;</span>, pkt<span class="variable">.s_array</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>2、Dynamic Array</strong></p>
<p>​	动态数组是在数组声明时其大小未预先确定的数组。由于可以随时向数组中添加新元素，所以这些数组的大小可以变化。</p>
<p>​	下面来看一个示例，在这个示例中，我们使用空方括号 <code>[]</code> 声明一个 <code>rand</code> 类型的动态数组。定义了一个约束条件，将动态数组的大小限制在 5 到 8 之间。还定义了另一个约束条件，将数组中的每个元素赋值为其索引值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] 	d_array []; 	<span class="comment">// Declare a dynamic array with &quot;rand&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constrain size of dynamic array between 5 and 10</span></span><br><span class="line">  <span class="keyword">constraint</span> c_array &#123; d_array<span class="variable">.size</span>() &gt; <span class="number">5</span>; d_array<span class="variable">.size</span>() &lt; <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constrain value at each index to be equal to the index itself</span></span><br><span class="line">  <span class="keyword">constraint</span> c_val   &#123; <span class="keyword">foreach</span> (d_array[i])</span><br><span class="line">    					d_array[i] == i;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Utility function to display dynamic array contents</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> display();</span><br><span class="line">    <span class="keyword">foreach</span> (d_array[i])</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;d_array[%0d] = 0x%0h&quot;</span>, i, d_array[i]);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  Packet pkt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new packet, randomize it and display contents</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    pkt = <span class="keyword">new</span>();</span><br><span class="line">    pkt<span class="variable">.randomize</span>();</span><br><span class="line">    pkt<span class="variable">.display</span>();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	如果不对数组大小进行约束，随机化操作可能会生成一个空数组，这一情况适用于动态数组和队列。</p>
<p><strong>3、Queue randomization</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] 	queue [$]; 	<span class="comment">// Declare a queue with &quot;rand&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constrain size of queue between 5 and 10</span></span><br><span class="line">  <span class="keyword">constraint</span> c_array &#123; queue<span class="variable">.size</span>() == <span class="number">4</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  Packet pkt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new packet, randomize it and display contents</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    pkt = <span class="keyword">new</span>();</span><br><span class="line">    pkt<span class="variable">.randomize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tip : Use %p to display arrays</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;queue = %p&quot;</span>, pkt<span class="variable">.queue</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="（四）常见约束（Common-Constraints）"><a href="#（四）常见约束（Common-Constraints）" class="headerlink" title="（四）常见约束（Common Constraints）"></a>（四）常见约束（Common Constraints）</h3><p><strong>1、Simple expressions</strong></p>
<p>表达式中只能使用一个关系运算符<code>&lt; &lt;= &gt; &gt;=</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] min, typ, max;</span><br><span class="line"><span class="comment">// Valid expression</span></span><br><span class="line"><span class="keyword">constraint</span> my_range &#123; <span class="number">0</span> &lt; min;</span><br><span class="line">	                 typ &lt; max;</span><br><span class="line">	                 typ &gt; min;</span><br><span class="line">	                 max &lt; <span class="number">128</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>​	不能在<strong>约束块</strong>内进行<strong>赋值操作</strong>，因为约束块仅包含表达式。相反，你必须使用等价运算符 <code>==</code>，就像上述示例中名为 <code>my_min</code> 的约束那样，在该约束里 <code>min</code> 会被赋予 16 这个值，而其他所有变量都会被随机化。这是一种为变量固定特定值的方法，即便求解器试图对其进行随机化操作。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> my_min &#123;  min == <span class="number">16</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用更复杂的表达式，如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> my_min &#123; min == temp<span class="variable">.low</span> * <span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、inside operator</strong></p>
<p>可以使用内部运算符指定下限和上限作为下面显示的表达式的替代。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> my_range &#123; typ &gt; <span class="number">32</span>; typ &lt; <span class="number">256</span>; &#125;</span><br><span class="line"><span class="comment">// typ &gt;= 32 and typ &lt;= 256</span></span><br><span class="line"><span class="keyword">constraint</span> new_range &#123; typ <span class="keyword">inside</span> &#123;[<span class="number">32</span>:<span class="number">256</span>]&#125;; &#125;</span><br><span class="line"><span class="comment">// Choose from the following values</span></span><br><span class="line"><span class="keyword">constraint</span> spec_range &#123; <span class="keyword">type</span> <span class="keyword">inside</span> &#123;<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;; &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>inside</code> 结构（操作）包含了<strong>下限</strong>和<strong>上限</strong>。除非变量存在其他约束条件，否则 SV 会收集（<code>inside</code> 所指定范围内的）所有值，并以相等的概率在这些值中进行选择。</p>
<p><strong>3、Inverted inside operator</strong></p>
<p>​	如果想要<strong>特定范围之外</strong>的任何值，可以编写如下<strong>反转约束</strong>。这将产生一个从0到31的随机值，因为typ是一个8位变量，并且上限已经涵盖了它可以容纳的最大值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] typ;</span><br><span class="line"><span class="keyword">constraint</span> inv_range &#123; ! (typ <span class="keyword">inside</span> &#123;[<span class="number">3</span>:<span class="number">6</span>]&#125;); &#125;</span><br></pre></td></tr></table></figure>



<p><strong>4、Weighted distributions</strong></p>
<p>​	<code>dist</code> 操作符允许你创建带权重的分布，这样一来，某些值被选中的概率会比其他值更高。<code>:=</code> 操作符表示在指定范围内的每个特定值的权重是相同的，而 <code>:/</code> 操作符则表示权重将在所有值之间平均分配。</p>
<p><strong><code>:=</code> operator</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] typ;</span><br><span class="line"><span class="keyword">constraint</span> dist1 	&#123;  typ <span class="keyword">dist</span> &#123; <span class="number">0</span>:=<span class="number">20</span>, [<span class="number">1</span>:<span class="number">5</span>]:=<span class="number">50</span>, <span class="number">6</span>:=<span class="number">40</span>, <span class="number">7</span>:=<span class="number">10</span>&#125;; &#125;</span><br></pre></td></tr></table></figure>

<p>在dis1中，0的权重是20，6是40，7是10，而1到5是50，总共320。因此，选择0的概率是20&#x2F;320，选择1到5之间的值的概率是50&#x2F;320。</p>
<p><strong><code>:/</code> operator</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] typ;</span><br><span class="line"><span class="keyword">constraint</span> dist2  	&#123;  typ <span class="keyword">dist</span> &#123; <span class="number">0</span>:/<span class="number">20</span>, [<span class="number">1</span>:<span class="number">5</span>]:/<span class="number">50</span>, <span class="number">6</span>:/<span class="number">10</span>, <span class="number">7</span>:/<span class="number">20</span>&#125;; &#125;</span><br></pre></td></tr></table></figure>

<p>在dist2中，0的权重为20，6为10，7为20，而1到5的权重为50，因此每个权重为10。因此选择0的概率为20&#x2F;100，选择1到5之间的值的概率为10&#x2F;100。</p>
<p><strong>5、Bidirectional constraints</strong></p>
<p>​	<strong>约束块</strong>不像过程代码那样从上到下执行，而是同时处于活动状态。让我们用另一个例子来看看这个。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束c1和c2将值限制为10和11。</span></span><br><span class="line"><span class="keyword">constraint</span>  c1 &#123; val &gt; <span class="number">3</span>; val &lt; <span class="number">12</span>; &#125;</span><br><span class="line"><span class="keyword">constraint</span>  c2 &#123;val &gt;= <span class="number">10</span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="（五）内部约束"><a href="#（五）内部约束" class="headerlink" title="（五）内部约束"></a>（五）内部约束</h3><p>​	在 SystemVerilog 中，<code>inside</code> 关键字可用于检查给定值是否处于 <code>inside</code> 语句所指定的范围内。除了用作<strong>约束条件</strong>外，它还能在 <code>if</code> 等条件语句中使用。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;variable&gt; <span class="keyword">inside</span> &#123;&lt;values <span class="keyword">or</span> range&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inverted &quot;inside&quot;</span></span><br><span class="line">!(&lt;variable&gt; <span class="keyword">inside</span> &#123;&lt;values <span class="keyword">or</span> range&gt;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_var <span class="keyword">inside</span> &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>&#125; 		<span class="comment">// Check if m_var is either 4,7 or 9</span></span><br><span class="line">m_var <span class="keyword">inside</span> &#123;[<span class="number">10</span>:<span class="number">100</span>]&#125; 	<span class="comment">// Check if m_var is between 10 and 100 inclusive</span></span><br></pre></td></tr></table></figure>

<p><strong>条件语句中使用<code>inside</code></strong>	</p>
<p>​	在下面的示例中，<code>inside</code> 操作符在 <code>if-else</code> 语句和三元运算符中都有使用。如果 <code>m_data</code> 的随机值处于 4 到 9 这个范围内（包含 4 和 9），<code>flag</code> 会被赋值为 1；若不在此范围内，<code>flag</code> 则被赋值为 0。</p>
<p>​	同样地，<code>if-else</code> 代码块也使用了相同的操作符，并输出一条显示信息。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used in a ternary operator</span></span><br><span class="line">flag = m_data <span class="keyword">inside</span> &#123;[<span class="number">4</span>:<span class="number">9</span>]&#125; ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Used with &quot;if-else&quot; operators</span></span><br><span class="line"><span class="keyword">if</span> (m_data <span class="keyword">inside</span> &#123;[<span class="number">4</span>:<span class="number">9</span>]&#125;)</span><br><span class="line">	<span class="built_in">$display</span> (<span class="string">&quot;m_data=%0d INSIDE [4:9], flag=%0d&quot;</span>, m_data, flag);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">$display</span> (<span class="string">&quot;m_data=%0d outside [4:9], flag=%0d&quot;</span>, m_data, flag);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>约束中使用<code>inside</code></strong></p>
<p><code>inside</code>运算符在约束中非常有用，并使代码更短、更具可读性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constrain m_var to be either 3,4,5,6 or 7</span></span><br><span class="line"><span class="keyword">constraint</span> c_var &#123; m_var <span class="keyword">inside</span> &#123;[<span class="number">3</span>:<span class="number">7</span>]&#125;; &#125;</span><br></pre></td></tr></table></figure>



<p><strong>Inverted <code>inside</code></strong></p>
<p>​	与<code>inside</code>所做的相反，可以通过在其前面放置一个not符号<code>!</code>来实现。这适用于<strong>约束</strong>和<strong>条件语句</strong>。下面的示例与我们之前看到的相同，只是它的约束已被调整以反映反转的内部语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inverted inside: Constrain m_var to be outside 3 to 7</span></span><br><span class="line"><span class="keyword">constraint</span> c_var &#123; !(m_var <span class="keyword">inside</span> &#123;[<span class="number">3</span>:<span class="number">7</span>]&#125;); &#125;</span><br></pre></td></tr></table></figure>



<h3 id="（六）蕴含约束Implication-Constraint"><a href="#（六）蕴含约束Implication-Constraint" class="headerlink" title="（六）蕴含约束Implication Constraint"></a>（六）蕴含约束Implication Constraint</h3><p>SystemVerilog提供了两种结构来声明条件关系——<strong>implication</strong>和<strong>if else</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implication operator &quot;-&gt;&quot; tells that len should be</span></span><br><span class="line"><span class="comment">// greater than 10 when mode is equal to 2</span></span><br><span class="line"><span class="keyword">constraint</span> c_mode &#123;  mode == <span class="number">2</span> -&gt; len &gt; <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Same thing can be achieved with &quot;if-else&quot; construct</span></span><br><span class="line"><span class="keyword">constraint</span> c_mode &#123; <span class="keyword">if</span> (mode == <span class="number">2</span>) len &gt; <span class="number">10</span>;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Implication  Operator</strong></p>
<p>蕴含操作符 <code>-&gt;</code> 可用于<strong>约束</strong>表达式中，以表明两个变量之间的条件关系。</p>
<p>如果 <code>-&gt;</code> 操作符左侧（LHS）的表达式为真，那么右侧（RHS）的约束表达式就必须得到满足。如果左侧的表达式不为真，那么右侧的约束表达式将不被考虑。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If 5 &lt;= mode &lt;= 11, mod_en should be 1</span></span><br><span class="line"><span class="keyword">constraint</span> c_mode &#123;	mode <span class="keyword">inside</span> &#123;[<span class="number">4&#x27;h5</span>:<span class="number">4&#x27;hB</span>]&#125; -&gt; mod_en == <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>



<p><strong>if-else Constraint</strong></p>
<p>​	<code>if-else</code> 约束提供了一种指定条件表达式中 <code>else</code> 部分的选项。如果条件表达式为真，那么在第一个约束集里指定的所有约束都必须得到满足。否则，将满足可选 else 部分中的所有约束。</p>
<p>​	嵌套的 <code>if-else</code> 代码块是被允许的，并且多个约束语句需要用花括号 <code>&#123; &#125;</code> 括起来。这类似于在诸如 <code>initial</code> 和 <code>always</code> 这样的过程块中使用的 <code>begin-end</code> 结构。然而，约束被归类为<strong>声明性代码</strong>，因此需要使用花括号来括住，而不是 <code>begin-end</code> 。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constraint</span> c_mode &#123;</span><br><span class="line">	<span class="comment">// If 5 &lt;= mode &lt;= 11, then constrain mod_en to 1</span></span><br><span class="line">	<span class="comment">// This part only has 1 statement and hence do not</span></span><br><span class="line">	<span class="comment">// require curly braces &#123;&#125;</span></span><br><span class="line">	<span class="keyword">if</span> (mode <span class="keyword">inside</span> &#123;[<span class="number">4&#x27;h5</span>:<span class="number">4&#x27;hB</span>]&#125;)	</span><br><span class="line">	    mod_en == <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// If the above condition is false, then do the following</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// If mode is constrained to be 1, then mod_en should be 1</span></span><br><span class="line">		<span class="keyword">if</span> ( mode == <span class="number">4&#x27;h1</span>) &#123;</span><br><span class="line">			mod_en == <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// If mode is any other value than 1 and not within</span></span><br><span class="line">			<span class="comment">// 5:11, then mod_en should be constrained to 0</span></span><br><span class="line">	 		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	   			mod_en == <span class="number">0</span>;</span><br><span class="line">	 		&#125;</span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="（七）foreach约束"><a href="#（七）foreach约束" class="headerlink" title="（七）foreach约束"></a>（七）foreach约束</h3><p>SystemVerilog支持在约束内使用<code>foreach</code>循环，以便可以约束数组。<code>foreach</code>构造遍历数组的元素，其参数是表示数组中单个实体的标识符。</p>
<p>约束使用foreach循环遍历所有元素并将每个元素的值分配给其索引的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This constraint will iterate through each of the 5 elements</span></span><br><span class="line"><span class="comment">// in an array and set each element to the value of its particular index</span></span><br><span class="line"><span class="keyword">constraint</span> c_array &#123; <span class="keyword">foreach</span> (array[i]) &#123;</span><br><span class="line">    					array[i] == i;</span><br><span class="line">  						&#125;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、Dynamic Array&#x2F;Queue</strong></p>
<p>​	<strong>动态数组</strong>和<strong>队列</strong>在声明时没有大小，因此不能直接使用foreach循环。因此，数组的大小必须直接分配或作为约束集的一部分进行约束。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] darray []; 		<span class="comment">// Dynamic array -&gt; size unknown</span></span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] queue [$]; 		<span class="comment">// Queue -&gt; size unknown</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign size for the queue if not already known</span></span><br><span class="line">  <span class="keyword">constraint</span> c_qsize  &#123; queue<span class="variable">.size</span>() == <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constrain each element of both the arrays</span></span><br><span class="line">  <span class="keyword">constraint</span> c_array  &#123; <span class="keyword">foreach</span> (darray[i])</span><br><span class="line">    					  darray[i] == i;</span><br><span class="line">                        <span class="keyword">foreach</span> (queue[i])</span><br><span class="line">                          queue[i] == i + <span class="number">1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line"><span class="comment">// 和对队列操作一样，数组的大小可以通过约束来指定。不过，在调用随机化操作之前要直接指定数组的大小。</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span> ();</span><br><span class="line">		darray = <span class="keyword">new</span>[<span class="number">5</span>]; 	<span class="comment">// Assign size of dynamic array</span></span><br><span class="line">	<span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<p><strong>2、多维数组（Multidimensional Arrays）</strong></p>
<p>SystemVerilog约束足够强大，也可以应用于多维数组。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">4</span>:<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>] md_array [<span class="number">2</span>][<span class="number">5</span>]; 	<span class="comment">// Multidimansional Arrays</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> c_md_array &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (md_array[i]) &#123;</span><br><span class="line">    	<span class="keyword">foreach</span> (md_array[i][j]) &#123;</span><br><span class="line">          <span class="keyword">foreach</span> (md_array[i][j][k]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k %<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">              md_array[i][j][k] == <span class="number">&#x27;hF</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              md_array[i][j][k] == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<p><strong>3、多维动态数组</strong></p>
<p>约束多维动态数组有点棘手，可能并非所有模拟器都支持。在下面显示的示例中，二维数组md_array的X或Y元素的大小未知。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] md_array [][]; 	<span class="comment">// Multidimansional Arrays with unknown size</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> c_md_array &#123;</span><br><span class="line">     <span class="comment">// First assign the size of the first dimension of md_array</span></span><br><span class="line">     md_array<span class="variable">.size</span>() == <span class="number">2</span>;</span><br><span class="line">     <span class="comment">// Then for each sub-array in the first dimension do the following:</span></span><br><span class="line">     <span class="keyword">foreach</span> (md_array[i]) &#123;</span><br><span class="line">        <span class="comment">// Randomize size of the sub-array to a value within the range</span></span><br><span class="line">        md_array[i]<span class="variable">.size</span>() <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">5</span>]&#125;;</span><br><span class="line">        <span class="comment">// Iterate over the second dimension</span></span><br><span class="line">        <span class="keyword">foreach</span> (md_array[i][j]) &#123;</span><br><span class="line">           <span class="comment">// Assign constraints for values to the second dimension</span></span><br><span class="line">           md_array[i][j] <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<p><strong>4、Array Reduction Iterative Constraint数组缩减迭代约束</strong></p>
<p>​	这是 SystemVerilog 支持的另一种相当有用的结构和技术。数组缩减方法能够从一个未打包的整数数组中<strong>生成一个单一的值</strong>。这种方法可以在约束条件中使用，从而使表达式在随机化过程中被考虑进去。</p>
<p>​	例如，假设有一个包含 N 个元素的数组需要进行随机化，要求所有元素的总和等于某个特定值。可以结合 <code>with</code> 子句使用数组缩减运算符，这样它会遍历数组的每个元素，并将其纳入约束求解器的考虑范围。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span>[<span class="number">3</span>:<span class="number">0</span>] array [<span class="number">5</span>];</span><br><span class="line"><span class="comment">// Intrepreted as int&#x27;(array[0]) + int&#x27;(array[1])+ .. +int&#x27;(array[4]) == 20;</span></span><br><span class="line">  <span class="keyword">constraint</span> c_sum &#123; array<span class="variable">.sum</span>() <span class="keyword">with</span> (<span class="keyword">int</span>&#x27;(item)) == <span class="number">20</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<h3 id="（八）solve-before-Constraint先求解约束"><a href="#（八）solve-before-Constraint先求解约束" class="headerlink" title="（八）solve before Constraint先求解约束"></a>（八）solve before Constraint先求解约束</h3><p>​	SystemVerilog 的约束求解器在默认情况下，会尝试给出随机值的均匀分布。因此，对于给定的约束条件，任何合法值成为其解的概率都是相同的。</p>
<p>​	但是，使用 <code>solve - before（先求解）</code> 指令可以改变概率分布，从而使得某些极端情况（边角情况）被选中的概率比其他情况更高。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span>  <span class="keyword">bit</span>			a;</span><br><span class="line">  <span class="keyword">rand</span>  <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] 	b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> c_ab &#123; a -&gt; b == <span class="number">3&#x27;h3</span>;</span><br><span class="line"><span class="comment">// 告知求解器，在尝试求解 “b” 之前必须先求解 “a”。因此，在这里 “a” 的值决定了 “b” 的值。</span></span><br><span class="line">                  	<span class="keyword">solve</span> a <span class="keyword">before</span> b;</span><br><span class="line">                  &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ABC abc = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="keyword">begin</span></span><br><span class="line">      abc<span class="variable">.randomize</span>();</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;a=%0d b=%0d&quot;</span>, abc<span class="variable">.a</span>, abc<span class="variable">.b</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="（九）Static-Constraints静态约束"><a href="#（九）Static-Constraints静态约束" class="headerlink" title="（九）Static Constraints静态约束"></a>（九）Static Constraints静态约束</h3><p>​	就像类中的静态变量一样，约束可以声明为<strong>静态</strong>的。<strong>静态约束在所有类实例之间共享</strong>。</p>
<p>​	只有当使用**<code>constraint_mode（）</code><strong>方法打开和关闭约束时，它们才会受到<code>static</code>关键字的影响。当使用此方法关闭非静态约束时，该约束在调用该方法的类的特定实例中被关闭。但是，当使用此方法关闭和打开静态约束时，该</strong>约束**在类的所有实例中被打开和关闭。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [class_name];</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constraint</span> [constraint_name] [definition]</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>



<h3 id="（十）Randomization-Methods"><a href="#（十）Randomization-Methods" class="headerlink" title="（十）Randomization Methods"></a>（十）Randomization Methods</h3><p>​	在类中被声明为 <code>rand</code> 或 <code>randc</code> 的变量，可使用内置的 <code>randomize()</code> 方法进行随机化。若<strong>随机化成功</strong>，该方法会<strong>返回 1</strong>；若失败，则返回 0。随机化失败可能由多种原因导致，比如约束条件相互冲突，求解器无法找出满足所有约束条件的值等。<strong>类对象不会自动进行随机化</strong>，因此我们<strong>必须调用 <code>randomize()</code> 方法</strong>来实现随机化。</p>
<p><strong>1、Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">int</span> randomize ();</span><br></pre></td></tr></table></figure>

<p><strong>2、pre_randomize()</strong></p>
<p>​	这个函数定义在其对象将被随机化的同一个类中，并且会在调用 <code>randomization()</code> 方法<strong>之前</strong>被调用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> pre_randomize();</span><br></pre></td></tr></table></figure>

<p><strong>3、post_randomize()</strong></p>
<p>​	这个函数同样定义在其对象将被随机化的同一个类中，并且会在 <code>randomize()</code> 方法调用<strong>之后</strong>被调用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br></pre></td></tr></table></figure>

<p><strong>4、Override</strong></p>
<p>​	我们之前所做的是用自己的定义去覆盖现有的空的 <code>pre_randomize()</code> 和 <code>post_randomize()</code> 方法。这是一种巧妙改变对象随机化特性的方法。如果该类是一个派生类，并且不存在用户自定义的这两个方法的实现，那么这两个方法都会自动调用其基类的对应函数。</p>
<p>​	需要注意的是，<code>pre_randomize()</code> 和 <code>post_randomize()</code> 并非<strong>虚方法</strong>，但表现得像虚方法一样。如果你尝试手动将它们声明为虚方法，可能会遇到如下所示的编译错误。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Beverage;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]	beer_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> pre_randomize ();</span><br><span class="line">  	<span class="built_in">$display</span> (<span class="string">&quot;This will be called just before randomization&quot;</span>);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"><span class="comment">// virtual function void pre_randomize ();                                  |</span></span><br><span class="line"><span class="comment">//ncvlog: *E,CLSMNV (testbench.sv,7|36): The pre_randomize() method cannot be declared virtual.</span></span><br></pre></td></tr></table></figure>

<p>还需注意以下几点：</p>
<ul>
<li><p>如果 <code>randomize()</code> 方法执行失败，那么 <code>post_randomize()</code> 方法将不会被调用。</p>
</li>
<li><p><code>randomize()</code> 方法是内置方法，无法被覆盖。</p>
</li>
<li><p>如果随机化操作失败，那么变量将保留其原始值，不会被修改。</p>
</li>
</ul>
<h3 id="（十一）Inline-Constraints内联约束"><a href="#（十一）Inline-Constraints内联约束" class="headerlink" title="（十一）Inline Constraints内联约束"></a>（十一）Inline Constraints内联约束</h3><p>​	假设一个类已经定义好了完善的约束条件，但现在需要根据用户确定的一组不同约束来对该类的变量进行随机化。借助 <code>with</code> 结构，用户可以在调用 <code>randomize()</code> 方法时声明<strong>内联约束</strong>。求解器会将这些<strong>额外的约束</strong>与对象<strong>原有的约束</strong>一同考虑。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果原始约束c_id已固定为25，如下，而又提供了一个与之冲突的内联值，那么随机化将会失败。</span></span><br><span class="line"><span class="keyword">class</span> Item;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] id;</span><br><span class="line">  <span class="keyword">constraint</span> c_id &#123; id &lt; <span class="number">25</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Item itm = <span class="keyword">new</span> ();</span><br><span class="line">    itm<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; id == <span class="number">10</span>; &#125;; 		</span><br><span class="line">    <span class="comment">// In-line constraint using with construct</span></span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">&quot;Item Id = %0d&quot;</span>, itm<span class="variable">.id</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h3 id="（十二）Soft-Constraints软约束"><a href="#（十二）Soft-Constraints软约束" class="headerlink" title="（十二）Soft Constraints软约束"></a>（十二）Soft Constraints软约束</h3><p>​	通常的约束被称为 “硬约束”，因为求解器必须始终满足这些约束条件。如果求解器无法找到满足这些约束的解，那么随机化操作就会失败。</p>
<p>​	然而，被声明为<code>soft</code>的约束则给予求解器一定的灵活性。也就是说，当存在其他相互矛盾的约束（无论是硬约束，还是优先级更高的软约束）时，该软约束并非必须要得到满足。软约束用于为随机变量<strong>指定默认值</strong>和<strong>分布情况</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ABC;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] data;</span><br><span class="line">  <span class="comment">// This constraint is defined as &quot;soft&quot;</span></span><br><span class="line">    <span class="keyword">constraint</span> c_data &#123; <span class="keyword">soft</span> data &gt;= <span class="number">4</span>; data &lt;= <span class="number">12</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  ABC abc;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    abc = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="keyword">begin</span></span><br><span class="line">      abc<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; data == <span class="number">2</span>; &#125;;</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;abc = 0x%0h&quot;</span>, abc<span class="variable">.data</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">// 输出abc的值将显示未2，这是有soft的特性决定的</span></span><br></pre></td></tr></table></figure>

<p>如果<code>c_data</code>去掉<code>soft</code>修改为硬约束的话，那么运行会发生错误，因为存在相互矛盾的约束条件。</p>
<h3 id="（十三）Disable-Constraints"><a href="#（十三）Disable-Constraints" class="headerlink" title="（十三）Disable Constraints"></a>（十三）Disable Constraints</h3><p>​	所有约束默认启用，并将在随机化期间由SystemVerilog约束求解器考虑。随机化期间不考虑禁用的约束。<code>constraint_mode()</code>可以<strong>启用</strong>或<strong>禁用</strong>约束。</p>
<p><strong>Syntax</strong></p>
<p><code>constraint_mode()</code>既可以作为<strong>任务</strong>调用，也可以作为<strong>函数</strong>调用。</p>
<p>​	当作为<strong>任务调用</strong>时，该方法<strong>不返回任何内容</strong>。为任务提供输入参数以打开或关闭给定约束。作为函数调用时，该方法返回给定约束的当前状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called as a task</span></span><br><span class="line">class_obj<span class="variable">.const_name</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>); 			<span class="comment">// Turn off the constraint</span></span><br><span class="line">class_obj<span class="variable">.const_name</span><span class="variable">.constraint_mode</span>(<span class="number">1</span>); 			<span class="comment">// Turn on the constraint</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Called as a function</span></span><br><span class="line">status = class_obj<span class="variable">.const_name</span><span class="variable">.constraint_mode</span>(); 	<span class="comment">// status is an int variable to hold return value</span></span><br></pre></td></tr></table></figure>





<h3 id="（十四）Disable-Randomization"><a href="#（十四）Disable-Randomization" class="headerlink" title="（十四）Disable Randomization"></a>（十四）Disable Randomization</h3><p>可以通过调用 <code>rand_mode</code> 方法来禁用类中变量的随机化功能。</p>
<p>这与用于禁用约束的 <code>constraint_mode()</code> 方法非常相似。因此，一个被禁用的随机变量会被当作未被声明为 <code>rand</code> 或 <code>randc</code> 一样来处理。</p>
<p><code>rand_mode</code> 既可以作为<strong>函数调用</strong>，也可以作为<strong>任务调用</strong>。如果将其作为函数调用，它会返回该变量当前的状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disables randomization of variable [variable_name] inside [class_object] class</span></span><br><span class="line">[class_object].[variable_name]<span class="variable">.rand_mode</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enables randomization of variable [variable_name] inside [class_object] class</span></span><br><span class="line">[class_object].[variable_name]<span class="variable">.rand_mode</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="（十五）Random-Weighted-Case"><a href="#（十五）Random-Weighted-Case" class="headerlink" title="（十五）Random Weighted Case"></a>（十五）Random Weighted Case</h3><p>​	有时候，我们会遇到这样的场景：希望求解器从多个语句中随机挑选一个来执行。关键字 <code>randcase</code> 引入了一种特殊的 <code>case</code> 语句，它能够随机选择其中一个分支。<code>case</code> 项表达式是正整数值，这些值代表与每个项相关联的权重。选择某个项的概率是通过该项的权重除以所有权重之和得出的。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">randcase</span></span><br><span class="line">	item  :  statement;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<p>​	所有权重之和为9，因此选择第一个分支的概率为1&#x2F;9或11.11%，选择第二个分支的概率为5&#x2F;9或55.56%，选择最后一个分支的概率为3&#x2F;9或33.33%。</p>
<p>​	如果分支指定了零权重，则不采用该分支。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      	<span class="keyword">randcase</span></span><br><span class="line">          	<span class="number">0</span>   : 	<span class="built_in">$display</span> (<span class="string">&quot;Wt 0&quot;</span>);</span><br><span class="line">        	<span class="number">1</span> 	: 	<span class="built_in">$display</span> (<span class="string">&quot;Wt 1&quot;</span>);</span><br><span class="line">      		<span class="number">5</span> 	: 	<span class="built_in">$display</span> (<span class="string">&quot;Wt 5&quot;</span>);</span><br><span class="line">      		<span class="number">3</span> 	: 	<span class="built_in">$display</span> (<span class="string">&quot;Wt 3&quot;</span>);</span><br><span class="line">      	<span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	每次调用 <code>randcase</code> 时，都会获取一个介于 0 到所有权重之和范围内的随机数。然后，这些权重会按照声明的顺序来进行选择：较小的随机数对应于第一个（最上面的）权重语句。</p>
<h2 id="九、Misc-Constructs"><a href="#九、Misc-Constructs" class="headerlink" title="九、Misc Constructs"></a>九、Misc Constructs</h2><h3 id="（一）Program-Block"><a href="#（一）Program-Block" class="headerlink" title="（一）Program Block"></a>（一）Program Block</h3><p>​	<strong>module</strong>是用于构建设计的基本结构。每个module可以包含其他module、nets、variables和其他过程块的层次结构，以描述任何硬件功能。另一方面，testbench验证设计的完整环境，因此重点放在对其建模的方式上，以使其更具可重用性和有效性。它必须正确初始化和同步，避免设计和测试平台之间的竞争条件。</p>
<p><strong>Program block</strong>的引入的原因是什么？</p>
<ul>
<li>为Testbenchs的执行提供切入点</li>
<li>创建一个容器来保存所有其他testbench数据，例如task、class object和function</li>
<li>通过在仿真周期的反应区域执行来避免设计中的竞争条件</li>
</ul>
<p>​	**反应区(reactive region)**是仿真时间推进前的最后几个阶段之一，到那时，所有设计元素语句都将执行完毕，测试平台将看到更新后的值。在设计语句和测试平台语句的执行之间设置这样的划分是很重要的，因为这会使不同仿真器之间的输出更具确定性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Syntax</span></span><br><span class="line"><span class="keyword">program</span> [name] [port_list];</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Examples</span></span><br><span class="line"><span class="keyword">program</span> test1 (<span class="keyword">input</span> clk, reset);</span><br><span class="line">	<span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> test2 (<span class="keyword">interface</span> wb_if);</span><br><span class="line">	<span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">program</span> test3;</span><br><span class="line">	<span class="keyword">initial</span> ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>Program block</strong>可以嵌套在module和interface中，因此同一个module中的多个programs可以共享该范围内的<strong>局部变量</strong>。下面的例子中mode是tb中的局部变量，programs p1和p2都可以访问。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] mode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">program</span> p1;</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">endprogram</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">program</span> p2;</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">endprogram</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="（二）Cast-Dynamic"><a href="#（二）Cast-Dynamic" class="headerlink" title="（二）Cast Dynamic"></a>（二）Cast Dynamic</h3><p>​	当需要在两个不同数据类型的变量之间进行赋值时，普通赋值操作可能并不适用，此时应使用名为 <code>$cast</code> 的系统任务。</p>
<p>​	<code>$cast</code> 既可以作为任务调用，也可以作为函数调用。二者的区别在于，当作为<strong>函数</strong>使用时，如果<strong>类型转换合法</strong>，它会<strong>返回 1</strong>。这在处理无效赋值时非常有用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> <span class="built_in">$cast</span> (targ_var, source_exp);</span><br><span class="line"><span class="keyword">task</span> <span class="built_in">$cast</span> (targ_var, source_exp);</span><br></pre></td></tr></table></figure>

<p>当 <code>$cast</code> 作为任务调用时，它会尝试将源表达式赋值给目标变量。若该赋值无效，将会出现运行时错误，且目标变量的值保持不变。</p>
<p>当 <code>$cast</code> 作为<strong>函数调用</strong>时，它同样会尝试把源表达式赋值给目标变量。若赋值成功，函数返回 1；若赋值失败，则不会进行赋值操作，函数返回 0。需要注意的是，在这种情况下不会出现运行时错误，仿真会继续进行，目标变量的值也不会改变。 </p>
<h3 id="（三）Package"><a href="#（三）Package" class="headerlink" title="（三）Package"></a>（三）Package</h3><p><strong>Verilog</strong> 在全局声明方面存在显著局限性，特别是在函数和用户自定义类型方面。</p>
<p><strong>局部作用域：<strong>在 Verilog 中，在模块内声明的所有对象都只在该模块内有效。这意味着，任何</strong>函数</strong>或<strong>任务</strong>若要在多个模块中使用，都必须在每个需要它的模块中重新声明。这会导致代码冗余，并且增加了维护工作量。</p>
<p>**层次化引用：**虽然 Verilog 允许使用层次化引用来访问其他模块中的对象，但这些引用仅用于验证目的，并不代表实际的硬件行为。因此，它们是不可综合的。层次化引用通常用于在测试平台中访问设计模块内部的信号，以进行验证和调试。</p>
<p>**用户自定义类型：**在实际设计中，常常需要在多个模块中使用用户自定义类型。然而，由于缺乏全局声明机制，这些类型也必须在每个模块中重新定义，这进一步加剧了代码重复的问题。</p>
<p><strong>1、SystemVerilog Package</strong></p>
<p>​	SystemVerilog package提供了一种存储和共享数据、方法、属性以及参数的方式，这些数据、方法等可以在多个模块、接口或程序中重复使用。<strong>Packages</strong>具有显式定义的作用域，<strong>该作用域与顶层模块处于同一层级</strong>，这使得所有的参数和枚举类型都可以在这个作用域内被引用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> &lt;package_name&gt;;</span><br><span class="line">  <span class="comment">// Typedef declarations</span></span><br><span class="line">  <span class="comment">// Function/Task definitions</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>

<p>​	Package是一个独立的命名空间，并不嵌入在 Verilog 模块内部。通过将定义和声明置于 <code>package</code> 和 <code>endpackage</code> 之间，可以防止全局命名空间中的混乱。</p>
<blockquote>
<p>注意！Package不能包含层次化引用，除非这些引用是在Package内部创建的或者是被导入进来的。</p>
</blockquote>
<p><strong>2、Package Example</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my_pkg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create typedef declarations that can be reused in multiple modules</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] &#123; RED, YELLOW, GREEN, RSVD &#125; e_signal;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>]   signal_id;</span><br><span class="line">                     <span class="keyword">bit</span>         active;</span><br><span class="line">                     <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>]   timeout;</span><br><span class="line">                   &#125; e_sig_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create function and task defintions that can be reused</span></span><br><span class="line">    <span class="comment">// Note that it will be a &#x27;static&#x27; method if the keyword &#x27;automatic&#x27; is not used</span></span><br><span class="line">    <span class="comment">// 不显示声明为automatic，默认就声明为静态方法</span></span><br><span class="line">	<span class="keyword">function</span> <span class="keyword">int</span> calc_parity ();</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;Called from somewhere&quot;</span>);</span><br><span class="line">   	<span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endpackage</span></span><br></pre></td></tr></table></figure>

<p><strong>3、Package Import</strong></p>
<p>​	一个 <strong>SystemVerilog package</strong>可以使用关键字 <strong>“import”</strong>，后面跟着作用域解析操作符 <strong>“::”</strong> 被导入到当前作用域中，从而能够使用该程序包中的各项内容。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;package_name&gt;::*; <span class="comment">// Imports all items</span></span><br><span class="line"><span class="keyword">import</span> &lt;package_name&gt;::&lt;item_name&gt;; <span class="comment">// Imports specific item</span></span><br></pre></td></tr></table></figure>

<p><strong>4、Wildcard Import</strong></p>
<p>​	当使用通配符（*）导入package中的item时，只有那些在module或interface中实际被使用到的项目才会被导入。Package中任何未被引用的定义和声明仍不会被导入。所以，本质上来说，一次导入操作意味着让被导入的项目变得可见（可被使用）。</p>
<p><strong>5、Import Specific Items</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] &#123; RED, YELLOW, GREEN, RSVD &#125; e_signal;</span><br><span class="line"><span class="comment">// Although e_signal is made visible, enumerated labels will not be made visible</span></span><br><span class="line"><span class="keyword">import</span> my_pkg::e_signal;</span><br><span class="line"><span class="comment">// 除了枚举名，枚举标签也要导入</span></span><br><span class="line"><span class="keyword">import</span> my_pkg::GREEN;</span><br><span class="line"><span class="keyword">import</span> my_pkg::e_signal;</span><br><span class="line"><span class="keyword">import</span> my_pkg::common;</span><br><span class="line"><span class="comment">// 请注意，在导入特定项目时，必须单独导入所有枚举的标签。</span></span><br></pre></td></tr></table></figure>

<p><strong>6、Search Order</strong></p>
<p>​	module或interface内的本地定义和声明优先于任何通配符导入。同样，从package中显式指定特定项目的导入也会优先于<strong>通配符导入</strong>。通配符导入本质上是在解析标识符时将搜索规则扩展到包含该package。软件工具会首先查找本地声明（遵循 Verilog 在模块内的搜索规则），然后查找通过通配符导入的任何package，最后查找 SystemVerilog 的 <code>$unit</code> 声明空间。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了让simulator从package中应用值，应使用::运算符显式提及包名称。</span></span><br><span class="line"><span class="comment">// 否则使用的就是module中的同名声明</span></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        e_wr_rd  	opc1 = READ;</span><br><span class="line">        e_rd_wr  	opc2 = my_pkg::READ;</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;READ1 = %0d READ2 = %0d &quot;</span>, opc1, opc2);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>7、Nested Package Reference</strong></p>
<p>包也可以导入另一个包。本地范围内的变量优先于导入的范围。</p>
<p><strong>8、Design Notes</strong></p>
<p><strong>Package</strong>可以包含的可综合结构如下：</p>
<ul>
<li><p><strong>参数、局部参数和常量变量的定义</strong>：参数可以在不同的设计模块中被复用，用于配置模块的行为。局部参数则主要在模块内部使用，用于一些局部的配置。常量变量在编译时就被确定值，并且在整个程序运行过程中不会改变。</p>
</li>
<li><p><strong>使用<code>typedef</code>定义的用户自定义类型</strong>：通过<code>typedef</code>可以创建新的数据类型，比如自定义的枚举类型、结构体类型等，方便在不同模块中统一使用这些类型。</p>
</li>
<li><p><strong>任务和函数的全自动化定义</strong>：这些任务和函数可以在不同的模块中被调用，实现代码的复用。这里的 “全自动化” 意味着这些任务和函数的定义符合可综合的规则，能够被综合工具转换为硬件电路。</p>
</li>
<li><p><strong>对其他package的导入语句</strong>：通过导入其他程序包，可以使用其他程序包中定义的类型、函数等，进一步提高代码的复用性。</p>
</li>
</ul>
<blockquote>
<p> 可以通过<code>import</code>导入package，也可以直接通过<code>::</code>进行引用。</p>
</blockquote>
<p>​	当一个module调用package中定义的task或function时，综合工具会复制该功能，就好像这个task或function是直接在模块内部定义的一样。为了使程序包中的任务和函数能够被<strong>综合</strong>，它们必须被声明为<code>automatic</code>的，并且不能包含静态变量(static variable)。</p>
<p>​	综合工具不支持在package中声明变量。在仿真时，程序包中的变量会在所有导入该程序包的模块之间共享，这使得一个模块可以对该变量进行写入操作，而另一个模块可以访问更新后的值。这种<strong>绕过模块端口的模块间通信</strong>方式是不可综合的。</p>
<p>注意：使用package编写可综合代码时，要遵循下列要求：</p>
<p><strong>（1）package中task和function的可综合性</strong></p>
<ul>
<li>**自动声明：**在 SV 中，要使package中的task和function能够被综合成硬件电路，必须将它们声明为<code>automatic</code>。<code>automatic</code>意味着每次调用任务或函数时都会创建新的局部变量实例，这符合硬件的并行执行特性。</li>
<li><strong>无静态变量：<strong>静态变量在函数或任务的多次调用之间会保留其值，这与硬件的行为不同。硬件电路在每个时钟周期都会重新计算输出，不会保留上一次的状态（除非使用</strong>寄存器</strong>）。所以，package的任务和函数不能包含静态变量，否则无法被综合。</li>
</ul>
<p><strong>（2）package中变量声明的可综合性</strong></p>
<ul>
<li><strong>综合不支持：<strong>综合工具的目的是将代码转换为实际的硬件电路，而package中的</strong>变量共享机制</strong>无法直接映射到硬件上。硬件模块之间的通信通常是通过<strong>端口</strong>进行的，而不是通过共享变量。因此，在程序包中声明变量是不可综合的。</li>
<li><strong>仿真特性：<strong>在仿真环境中，程序包中的变量可以在多个导入该程序包的模块之间共享。这为模块间的通信提供了一种方便的方式，但这种方式</strong>无法在硬件中实现</strong>。</li>
</ul>
<h3 id="（四）Commandline-Input-命令行输入"><a href="#（四）Commandline-Input-命令行输入" class="headerlink" title="（四）Commandline Input(命令行输入)"></a>（四）Commandline Input(命令行输入)</h3><p>​	有时候为了节省时间需要避免对testbench重新编译，需要像bash或Perl等任何脚本语言一样接受来自命令行的值。在 SystemVerilog 中，这些信息会作为<strong>可选参数</strong>提供给仿真，这些参数总是以 <code>+</code> 字符开头。通过被称为 “plusargs” 的系统函数，在 SystemVerilog 代码里就可以访问从命令行传入的这些参数。</p>
<p><strong>Syntax</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$test$plusargs (user_string)</span><br><span class="line">$value$plusargs (user_string, variable)</span><br></pre></td></tr></table></figure>

<p><strong>$test$plusargs</strong></p>
<ul>
<li><strong>用途</strong>: 用于检查是否在命令行中传递了特定的参数。</li>
<li><strong>语法</strong>: <code>integer $test$plusargs(&quot;parameter_name&quot;);</code></li>
<li><strong>返回值</strong>: 如果命令行中存在指定的参数名，则返回非零值；否则返回0。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> ($test$plusargs (<span class="string">&quot;STANDBY&quot;</span>))</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;STANDBY argument is found ...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ($test$plusargs (<span class="string">&quot;STAND&quot;</span>))</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;STAND substring is found ...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ($test$plusargs (<span class="string">&quot;S&quot;</span>))</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;Some string starting with S found ...&quot;</span>);    </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>​	当使用<strong>运行时参数</strong> <code>+STANDBY</code> 对上述所示的代码进行编译和仿真时（其中 <code>STANDBY</code> 是提供给仿真工具的 <code>plusargs</code> 字符串参数），我们会得到如下所示的输出结果。请注意，<code>plusargs</code> 参数是区分大小写的，并且即使提供的字符串是 <code>STANDBY</code>，它也会匹配 “S” 和 “STAND”（只要命令行参数的前缀与之匹配即可）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ncsim&gt; run</span><br><span class="line">STANDBY argument is found ...</span><br><span class="line">STAND substring is found ...</span><br><span class="line">Some string starting with S found ...</span><br><span class="line">ncsim: *W,RNQUIE: Simulation is complete.</span><br></pre></td></tr></table></figure>

<p><strong>$value$plusargs</strong></p>
<ul>
<li><strong>用途</strong>: 用于获取命令行参数的值。</li>
<li><strong>语法</strong>: <code>integer $value$plusargs(&quot;parameter_name=%s&quot;, variable);</code></li>
<li><strong>返回值</strong>: 成功找到并解析参数时返回1，否则返回0。参数的值会被存储到提供的变量中。</li>
</ul>
<p>​	用户字符串的格式应为 “<code>plusarg_string</code> <code>format_string</code>”，其中格式字符串与 <code>$display</code> 任务中使用的格式字符串相同。这些格式标识符用于将通过命令行提供的值转换为指定的格式，并存储到变量里。</p>
<p>​	对于不同的输入参数，我们将得到不同的输出。另请注意，用户字符串&#x3D;和命令行表达式中的值之间<strong>不应有任何空格</strong>。</p>
<blockquote>
<p><strong>+STRING&#x3D;Joey</strong> or <strong>+STRING&#x3D;”Joey”</strong></p>
<p>“Joey”可以带双引号或不带双引号传递。</p>
</blockquote>
<p><strong>区别</strong></p>
<ul>
<li><strong>目的不同</strong>: <code>$test$plusargs</code> 主要用于检测是否存在某个命令行参数，而 <code>$value$plusargs</code> 则用于获取该参数的值。</li>
<li><strong>使用场景</strong>: 当你只需要知道某个选项是否被激活时，使用 <code>$test$plusargs</code>。当你需要根据命令行输入来配置你的仿真或设计参数时，使用 <code>$value$plusargs</code>。</li>
<li><strong>灵活性</strong>: <code>$value$plusargs</code> 提供了更高的灵活性，因为它允许你从命令行直接设置变量的值，这在进行快速测试和调试时非常有用。</li>
</ul>
<h3 id="（五）File-Operation"><a href="#（五）File-Operation" class="headerlink" title="（五）File Operation"></a>（五）File Operation</h3><p><strong>1、文件打开</strong></p>
<p>​	在进行文件读写操作之前，需要先使用 <code>$fopen</code> 系统函数来打开文件。该函数会返回一个文件描述符句柄，后续的读写操作都要用到这个句柄。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integer file_descriptor = $fopen(&quot;filename&quot;, &quot;mode&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filename</code>：要打开的文件名，需包含文件路径（如果文件不在当前工作目录下）。</li>
<li>mode：打开文件的模式，常见的模式有：<ul>
<li><code>&quot;r&quot;</code>：只读模式，用于读取已存在的文件。</li>
<li><code>&quot;w&quot;</code>：写入模式，若文件存在则清空内容，若不存在则创建新文件。</li>
<li><code>&quot;a&quot;</code>：追加模式，若文件存在则在文件末尾添加内容，若不存在则创建新文件。</li>
<li><code>&quot;r+&quot;</code>：读写模式，文件必须存在。</li>
<li><code>&quot;w+&quot;</code>：读写模式，若文件存在则清空内容，若不存在则创建新文件。</li>
<li><code>&quot;a+&quot;</code>：读写模式，若文件存在则在文件末尾添加内容，若不存在则创建新文件。</li>
</ul>
</li>
</ul>
<p><strong>2、文件写入</strong></p>
<p><strong>（1）<code>$fdisplay</code> 系统任务</strong></p>
<p><code>$fdisplay</code> 用于将格式化的字符串写入文件，并在末尾添加换行符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fdisplay(file_descriptor, &quot;format_string&quot;, arguments);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file_descriptor</code>：<code>$fopen</code> 函数返回的文件描述符句柄。</li>
<li><code>format_string</code>：格式化字符串，和 <code>$display</code> 函数中的格式字符串用法相同。</li>
<li><code>arguments</code>：可选参数，用于替换格式化字符串中的占位符。</li>
</ul>
<p><strong>（2）<code>$fwrite</code> 系统任务</strong></p>
<p><code>$fwrite</code> 用于将格式化的字符串写入文件，但不会在末尾添加换行符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fwrite(file_descriptor, &quot;format_string&quot;, arguments);</span><br></pre></td></tr></table></figure>



<p><strong>3、文件读取</strong></p>
<p><strong>（1）<code>$fgets</code> 系统任务</strong></p>
<p><strong><code>$fgets</code></strong> 用于从文件中读取一行内容，每次调用读取一行。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integer result = $fgets(string_variable, file_descriptor);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>string_variable</code>：用于存储读取到的字符串。</li>
<li><code>file_descriptor</code>：文件描述符句柄。</li>
<li><code>result</code>：返回值，若读取成功则返回读取的字符数，若到达文件末尾则返回 0。</li>
</ul>
<p><strong>（2）<code>$fscanf</code> 系统任务</strong></p>
<p><strong><code>$fscanf</code></strong> 用于从文件中按照指定的格式读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">integer result = $fscanf(file_descriptor, &quot;format_string&quot;, variable_list);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file_descriptor</code>：文件描述符句柄。</li>
<li><code>format_string</code>：格式化字符串，和 <code>$scanf</code> 函数中的格式字符串用法相同。</li>
<li><code>variable_list</code>：用于存储读取到的数据的变量列表。</li>
<li><code>result</code>：返回值，返回成功匹配并赋值的字段数量。</li>
</ul>
<p><strong>4、文件关闭</strong></p>
<p>完成文件读写操作后，需要使用 <code>$fclose</code> 系统任务关闭文件，以释放系统资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fclose(file_descriptor);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>file_descriptor</code>：文件描述符句柄。</li>
</ul>
<h3 id="（六）SystemVerilog-Callback"><a href="#（六）SystemVerilog-Callback" class="headerlink" title="（六）SystemVerilog Callback"></a>（六）SystemVerilog Callback</h3><p>​	SystemVerilog中的回调机制（Callback Mechanism）是一种<strong>设计模式</strong>，允许用户在特定事件发生时插入自定义的行为或逻辑，而无需修改原始代码。这种机制广泛应用于验证环境中，特别是UVM（Universal Verification Methodology）中，用于增强测试平台的灵活性和可扩展性。</p>
<p><strong>1、回调机制的基本概念</strong></p>
<p>​	回调机制的核心思想是通过预定义的接口或基类，让用户能够注册自己的函数或方法，在特定的钩子点（hook points）执行这些函数或方法。这种方法可以避免直接修改源代码，同时提供了一种灵活的方式来扩展功能。</p>
<p>​	回调机制的主要好处是实现组件之间的解耦。一个验证环境可以注册回调函数，这些回调函数能够在仿真过程中被执行，而无需修改原始设计。</p>
<p><strong>2、主要用途</strong></p>
<ul>
<li><p><strong>扩展测试平台的功能</strong>：例如在事务传输前后添加额外的检查或日志记录。</p>
</li>
<li><p>   <strong>定制化行为</strong>：不同的测试用例可以通过注册不同的回调函数来实现特定的行为。</p>
</li>
<li><p><strong>模块化的验证组件</strong>：提高代码的重用性和模块化程度，便于维护和扩展。</p>
</li>
</ul>
<p><strong>3、实现方式</strong></p>
<p><strong>（1）定义回调类（Callback）</strong></p>
<p>回调功能通常在定义了某些方法的类中实现。这些方法可以被其他类覆盖或扩展。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> callback_function();</span><br><span class="line">    <span class="comment">// Default implementation (optional)</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）注册回调对象Registration of Callbacks</strong></p>
<p>​	要使用回调，包含该方法的类必须向系统注册回调对象。这允许系统存储对稍后调用的方法的引用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyTest;</span><br><span class="line">  MyCallback cb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Registration of callback</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> register_callback(MyCallback callback);</span><br><span class="line">    cb = callback;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> execute();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">null</span>) <span class="keyword">begin</span></span><br><span class="line">      cb<span class="variable">.callback_function</span>();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）实现回调</strong></p>
<p>调用回调时必须执行的功能必须在子类中实现。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. Callback implementation</span></span><br><span class="line"><span class="keyword">class</span> UserCallback <span class="keyword">extends</span> MyCallback;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> callback_function();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;User-defined callback called!&quot;</span>);</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）调用回调</strong></p>
<p>​	在仿真过程中，当某个事件或条件发生时，会通过调用已注册的方法来触发回调。调用回调的类并不知晓回调具体会执行什么操作，这就实现了行为的灵活性。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    MyTest        test;</span><br><span class="line">    UserCallback  user_cb;</span><br><span class="line"></span><br><span class="line">    test    = <span class="keyword">new</span>;</span><br><span class="line">    user_cb = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register user-defined callback</span></span><br><span class="line">    test<span class="variable">.register_callback</span>(user_cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行将调用的回调函数</span></span><br><span class="line">    test<span class="variable">.execute</span>();</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>MyCallback</code> 类定义了一个虚拟函数 <code>callback_function()</code>。</p>
</li>
<li><p><code>MyTest</code> 类有一个函数用于注册回调，并在需要时执行该回调函数。</p>
</li>
<li><p><code>UserCallback</code> 继承自 <code>MyCallback</code> 并重写了 <code>callback_function()</code> 方法。</p>
</li>
<li><p>测试平台注册了 <code>UserCallback</code> 对象，并调用 <code>execute()</code>，该方法会调用已注册的回调函数。</p>
</li>
</ul>
<p><strong>4、回调与普通调用的区别</strong></p>
<p>回调机制允许在运行时动态地更改系统行为，而无需修改原始代码。主要特点如下：</p>
<ul>
<li><p><strong>动态性</strong>：回调可以在运行时注册并调用，提供了灵活性。</p>
</li>
<li><p><strong>解耦性</strong>：调用回调的模块不需要知道其实现细节，只需知道回调的存在，从而实现松耦合。</p>
</li>
<li><p><strong>通用性</strong>：调用者只需调用已注册的回调，而不关心具体执行内容。</p>
</li>
</ul>
<p>相比之下，常规函数或任务具有以下特点：</p>
<ul>
<li><p><strong>固定性</strong>：常规函数或任务在其定义的地方被显式调用，行为固定，除非重写。</p>
</li>
<li><p><strong>紧耦合</strong>：调用代码需要直接知道并依赖于具体的函数或任务，导致紧密耦合。</p>
</li>
</ul>
<p>总结来说，回调机制提供了一种灵活且松耦合的设计方式，使得系统更易于扩展和维护，而常规函数或任务则更适合于那些行为固定、明确的需求场景。</p>
<h2 id="十、功能覆盖率（Functional-Coverage）"><a href="#十、功能覆盖率（Functional-Coverage）" class="headerlink" title="十、功能覆盖率（Functional Coverage）"></a>十、功能覆盖率（Functional Coverage）</h2><h3 id="（一）功能覆盖率"><a href="#（一）功能覆盖率" class="headerlink" title="（一）功能覆盖率"></a>（一）功能覆盖率</h3><p><strong>什么是功能覆盖率？</strong>	</p>
<p>​	功能覆盖率是测试已经执行了设计的哪些功能&#x2F;特性的度量。这在<strong>约束随机验证</strong>（CRV）中非常有用，可帮助确定回归测试中的一组测试用例覆盖了哪些功能特性。</p>
<p><strong>它的局限性是什么？</strong></p>
<p>​	其效果完全取决于为其编写的代码质量。例如，若设计文档中提及了 10 个功能特性，但因疏忽或认知盲区遗漏了其中 3 个，则功能覆盖率代码仅会对剩余 7 个进行追踪。若测试中这 7 个功能均被覆盖，您可能会得出所有功能均已覆盖的错误结论。因此，<strong>必须确保功能覆盖率代码完整囊括设计规范中的所有需求条目</strong>。</p>
<p><strong>如何在systemverilog中实现功能覆盖？</strong></p>
<p>在测试平台中对关键变量进行采样，并分析其是否达到预定义的特定取值组合。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] mode;</span><br><span class="line">	<span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Other testbench code</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><code>mode</code> 变量可支持 16 种取值，<code>key</code> 变量可支持 4 种取值。若在仿真中存在监控机制对这两个变量进行追踪，并记录其具体取值组合，即可判定测试是否覆盖了特定功能特性。<strong>优势在于</strong>：</p>
<p>**自动化报告生成：**仿真器支持将此类覆盖率详细信息导出至文件（如 XML 或 CSV 格式），便于仿真结束后进行离线分析。</p>
<p>**跨测试合并：**可将不同测试用例生成的覆盖率文件合并至统一数据库（例如使用 <code>urg</code> 工具），实现全局覆盖率分析。</p>
<p><strong>示例场景：</strong></p>
<ul>
<li>测试用例 A 覆盖功能 X（如 <code>mode=5, key=1</code>）</li>
<li>测试用例 B 覆盖功能 Y（如 <code>mode=12, key=3</code>）</li>
<li>合并后的数据库将显示 <strong>X 和 Y 均已被覆盖</strong>，避免重复分析</li>
</ul>
<p><strong>覆盖率闭合验证</strong>：通过合并结果可快速识别未覆盖的 <code>mode</code>&#x2F;<code>key</code> 组合（如 <code>mode=8, key=0</code>），指导后续测试激励优化。</p>
<p><strong>如何编写covergroups？</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> myTrns;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] 	mode;</span><br><span class="line">	<span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] 	key;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">function</span> display ();</span><br><span class="line">      <span class="built_in">$display</span> (<span class="string">&quot;[%0tns] mode = 0x%0h, key = 0x%0h&quot;</span>, <span class="built_in">$time</span>, mode, key);</span><br><span class="line">   <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">covergroup</span> CovGrp;</span><br><span class="line">		<span class="keyword">coverpoint</span> mode &#123;</span><br><span class="line">			<span class="keyword">bins</span> featureA 	= &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="keyword">bins</span> featureB 	= &#123;[<span class="number">1</span>:<span class="number">3</span>]&#125;;</span><br><span class="line">			<span class="keyword">bins</span> common [] 	= &#123;<span class="number">4</span>:$&#125;;</span><br><span class="line">			<span class="keyword">bins</span> reserve	= <span class="keyword">default</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">coverpoint</span> key;</span><br><span class="line">	<span class="keyword">endgroup</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>变量被称为coverpoint</li>
<li>coverpoint放在一个covergroup中</li>
<li>可以创建多个covergroup以使用不同的bins对相同的变量进行采样</li>
<li>当变量达到相应的值时，bins被称为“命中&#x2F;覆盖”，因此当mode采用1,2或3时，bin feature B会被击中。</li>
<li>bin reserve是不属于其他bin的所有值的单个bin</li>
<li>common将有12个单独的bins，每个bins对应0x4到0xF的一个值</li>
</ul>
<p><strong>为什么仿真中缺少覆盖率指标？</strong></p>
<p>​	需启用工具厂商专用的命令行选项以导出覆盖率详细信息，随后通过 <strong>Cadence ICCR&#x2F;IMC</strong> 等覆盖率查看工具加载并解析该导出文件。</p>
<p><strong>操作流程示例</strong>：</p>
<p><strong>1、VCS 仿真器导出覆盖率</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用行/条件/翻转覆盖率，并指定输出目录  </span></span><br><span class="line">vcs -cm line+cond+tgl -cm_dir ./coverage_db  </span><br></pre></td></tr></table></figure>

<p><strong>2、Cadence IMC 查看覆盖率</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imc -execcmd <span class="string">&quot;load_test -testdir ./coverage_db; report_metrics&quot;</span>  </span><br></pre></td></tr></table></figure>

<p><strong>关键参数说明</strong>：</p>
<ul>
<li><code>-cm</code>：覆盖率模式开关（需与设计编译阶段保持一致）</li>
<li><code>-cm_dir</code>：指定覆盖率数据库存储路径</li>
<li><code>load_test</code>：IMC 命令，加载覆盖率数据</li>
<li><code>report_metrics</code>：生成覆盖率统计报告</li>
</ul>
<p><strong>如何确定采样时机？</strong></p>
<p><strong>实现方式</strong>：有两种方式实现covergroup中的覆盖率收集</p>
<ul>
<li>使用特定覆盖组的example()方法对改组内的覆盖点进行采样</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class myCov;</span><br><span class="line">	covergroup CovGrp;</span><br><span class="line">	 	...</span><br><span class="line">	endgroup</span><br><span class="line"></span><br><span class="line">	function new ();</span><br><span class="line">		CovGrp = new; 	        // Create an instance of the covergroup</span><br><span class="line">	endfunction</span><br><span class="line">endclass</span><br><span class="line"></span><br><span class="line">module tb_top;</span><br><span class="line">	myCov myCov0 = new ();   	// Create an instance of the class</span><br><span class="line"></span><br><span class="line">	initial begin</span><br><span class="line">		myCov0.CovGrp.sample ();</span><br><span class="line">	end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<ul>
<li>需明确指定覆盖率组（covergroup）的采样触发事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">covergroup CovGrp @ (posedge clk); 	// Sample coverpoints at posedge clk</span><br><span class="line">covergroup CovGrp @ (eventA); 	// eventA can be triggered with -&gt;eventA;</span><br></pre></td></tr></table></figure>

<p><strong>条件覆盖率实现方式是什么？</strong></p>
<p>有两种方法可以有条件的启用覆盖</p>
<ul>
<li>Use  <code>iff</code> construct</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> CovGrp;</span><br><span class="line">	<span class="keyword">coverpoint</span> mode <span class="keyword">iff</span> (!_if<span class="variable">.reset</span>) &#123;</span><br><span class="line">	    <span class="comment">// bins for mode</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Use <code>start</code> and <code>stop</code> functions</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CovGrp cg = new;</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">	#1 _if.reset = 0;</span><br><span class="line">	cg.stop ();</span><br><span class="line">	#10 _if.reset = 1;</span><br><span class="line">	cg.start();</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="（二）Covergroup-Coverpoint"><a href="#（二）Covergroup-Coverpoint" class="headerlink" title="（二）Covergroup &amp; Coverpoint"></a>（二）Covergroup &amp; Coverpoint</h3><p><strong>1、covergroup</strong>	</p>
<p><strong>（1）定义</strong></p>
<p><code>covergroup</code>是一种用户自定义类型，用于封装覆盖率模型的规范。它可以定义在程序包（package）、模块（module）、程序块（program）、接口（interface）或类（class）中。</p>
<p>通常会封装以下信息：</p>
<ul>
<li><p><strong>一组覆盖点（coverage points）</strong>：覆盖点用于指定需要收集覆盖率的信号或表达式的取值情况。例如，你可以为一个控制信号的不同取值设置覆盖点，以确保在仿真过程中该信号的各种可能取值都被遍历到。</p>
</li>
<li><p><strong>覆盖点之间的交叉覆盖率（cross coverage）</strong>：交叉覆盖率用于衡量多个覆盖点之间取值组合的覆盖情况。比如，有两个覆盖点分别对应两个不同的控制信号，交叉覆盖率可以帮助你了解这两个信号的所有可能取值组合是否都在仿真中出现过。</p>
</li>
<li><p><strong>定义覆盖组采样时机的事件（event）</strong>：覆盖组需要知道在何时进行采样以收集覆盖率信息。该时机通常由一个<strong>事件</strong>来定义，例如某个信号的上升沿、下降沿，或某个特定条件的满足等。</p>
</li>
<li><p><strong>配置覆盖率对象的其他选项</strong>：这些选项可以用来调整覆盖率收集的行为，比如设置覆盖率的权重、指定采样的范围等。</p>
</li>
</ul>
<p><strong>（2）语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">covergroup covergroup_name @(trigger_event);</span><br><span class="line">    // 覆盖点和交叉覆盖率定义</span><br><span class="line">endgroup</span><br></pre></td></tr></table></figure>

<ul>
<li><code>covergroup_name</code>：覆盖组的名称。</li>
<li><code>@(trigger_event)</code>：指定覆盖组的采样事件，即何时进行覆盖率数据的收集。可以是信号的边沿触发（如<code>posedge clk</code>）或条件表达式。</li>
</ul>
<p><strong>（3）作用</strong></p>
<p><code>covergroup</code> 可以将多个相关的覆盖点和交叉覆盖率定义组合在一起，方便管理和复用。一个覆盖组可以在不同的地方通过 <code>new</code> 函数多次实例化。</p>
<p><strong>2、coverpoint</strong>	</p>
<p><strong>（1）定义</strong></p>
<p><code>coverpoint</code> 用于指定需要收集覆盖率的信号或表达式的取值情况。它是覆盖组中的一个基本元素，每个覆盖点可以有多个取值范围或状态，称为 <code>bin</code>（仓）。</p>
<p><strong>（2）语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coverpoint signal_or_expression &#123;</span><br><span class="line">    // 仓定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>signal_or_expression</code>：要收集覆盖率的信号或表达式。</li>
</ul>
<p><strong>（3）仓（bin）</strong></p>
<p>仓是覆盖点的基本组成部分，用于定义信号或表达式的取值范围或状态。常见的仓定义方式有：</p>
<ul>
<li><strong>单个值</strong>：<code>binsof (signal) == value</code></li>
<li><strong>值范围</strong>：<code>binsof (signal) inside &#123;[min:max]&#125;</code></li>
<li><strong>多个值</strong>：<code>binsof (signal) inside &#123;value1, value2, ...&#125;</code></li>
</ul>
<p><strong>（4）作用</strong></p>
<p>通过定义覆盖点和仓，可以精确地指定需要验证的信号或表达式的各种取值情况，从而评估仿真是否覆盖了所有可能的情况。</p>
<p><strong>3、交叉覆盖率</strong>	</p>
<p>除了单个覆盖点的覆盖率，SystemVerilog 还支持交叉覆盖率的分析。交叉覆盖率用于衡量多个覆盖点之间取值组合的覆盖情况。</p>
<p><strong>（1）语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cross coverpoint1, coverpoint2, ...;</span><br></pre></td></tr></table></figure>



<h3 id="（三）Coverpoint-bins（覆盖桶）"><a href="#（三）Coverpoint-bins（覆盖桶）" class="headerlink" title="（三）Coverpoint bins（覆盖桶）"></a>（三）Coverpoint bins（覆盖桶）</h3><p><code>bins</code> 结构允许为覆盖点变量的给定可能取值范围内的每个值创建一个单独的仓（bin）。</p>
<h2 id="十一、断言（Assertions）"><a href="#十一、断言（Assertions）" class="headerlink" title="十一、断言（Assertions）"></a>十一、断言（Assertions）</h2><h3 id="（一）介绍"><a href="#（一）介绍" class="headerlink" title="（一）介绍"></a>（一）介绍</h3><p>断言是设计的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185743312&content_type=Article&match_order=1&q=%E5%B1%9E%E6%80%A7&zhida_source=entity">属性</a>的描述，主要用于验证设计的行为。此外，断言可以用来提供功能覆盖，并标记输入激励，用于验证不符合假设的要求。</p>
<ul>
<li>如果一个在模拟中被检查的属性不像我们期望的那样表现，那么这个断言失败。</li>
<li>如果一个被禁止在设计中出现的属性在模拟过程中发生，那么这个断言失败。</li>
</ul>
<p><strong>什么是设计属性？</strong></p>
<p>如果断言所检查的设计属性未按预期方式运行，断言就会失败。例如，假设设计发出授权请求，并期望在接下来的四个时钟周期内收到确认信号。但如果设计在第五个时钟周期才收到确认信号，那么 “应在 4 个时钟周期内返回确认信号” 这一属性就被违反了，断言失败。</p>
<p>如果断言所检查的设计属性被禁止出现，断言同样会失败。例如，假设一个小型处理器对从内存中读取的指令进行解码，遇到了一条未知指令，从而导致了致命错误。如果设计中绝不允许出现这种情况，那么 “只能从内存中读取有效指令” 这一设计属性就被违反了，断言失败。</p>
<p>从上述两个示例可以明显看出，我们可以通过编写 SystemVerilog 断言来检查给定设计的属性。</p>
<p><strong>为什么我们需要断言？</strong></p>
<p>断言不过是功能检查器的一种更简洁的表示形式。断言所代表的功能同样可以用 SystemVerilog 任务或检查器来实现，但这会涉及更多的代码行。这样做存在以下一些缺点：</p>
<ul>
<li><p>SystemVerilog 代码冗长，并且随着属性数量的增加，代码的维护和扩展变得困难。</p>
</li>
<li><p>作为一种过程式语言，要编写能够处理同一时间段内多个并行事件的检查器十分困难。</p>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A property written in Verilog/SystemVerilog</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!(a &amp;&amp; b))</span><br><span class="line">		<span class="built_in">$display</span> (<span class="string">&quot;Assertion failed&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>SystemVerilog断言是一种用于指定时间条件的声明性语言，非常简洁且更易于维护。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The property above written in SystemVerilog Assertions syntax</span></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span>(@(<span class="keyword">posedge</span> clk) a &amp;&amp; b);</span><br></pre></td></tr></table></figure>

<p><strong>断言语句类型：</strong></p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">assert</td>
<td align="left">它是一种描述，期望你的设计的某些属性一直为真</td>
</tr>
<tr>
<td align="left">assume</td>
<td align="left">将属性指定为环境的一个假设，当形式化工具使用信息生成输入激励时，仿真软件检查属性是否保持。是对验证环境的约束，意味着是条件，这些条件在环境中永远为真</td>
</tr>
<tr>
<td align="left">cover</td>
<td align="left">监测属性计算的覆盖范围，覆盖点被期望偶尔是对的</td>
</tr>
<tr>
<td align="left">restrict</td>
<td align="left">指定该属性作为形式化验证计算的约束。仿真软件不检查属性</td>
</tr>
</tbody></table>
<p><strong>Building Blocks of Assertions</strong></p>
<p><strong>序列Sequence</strong></p>
<p>​	在任何设计模型中，功能总是由多个逻辑事件的组合来表示的。这些事件可以是简单的同一个时钟边缘被求值的布尔表达式，或者是经过几个时钟周期的求值的事件。</p>
<p>​	为了简单起见，可以使用简单的断言来描述较小的事件，然后可以使用这些断言来构建更复杂的行为模式。</p>
<blockquote>
<p>序列是布尔表达式在时间上的组合</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Sequence syntax</span><br><span class="line">sequence &lt;name_of_sequence&gt;</span><br><span class="line">  &lt;test expression&gt;</span><br><span class="line">endsequence</span><br><span class="line"></span><br><span class="line">// Assert the sequence</span><br><span class="line">assert property (&lt;name_of_sequence&gt;);</span><br></pre></td></tr></table></figure>

<p><strong>属性Property</strong></p>
<p>属性是在仿真或者形式验证中被验证的<strong>单元</strong>。属性将序列通过逻辑或者有序地组合起来生成更复杂的序列，SVA提供关键词“property”来表达这些复杂的有序行为。</p>
<p>在属性中，可以使用“|-&gt;”、“|&#x3D;&gt;”来表达不同序列间的逻辑关系。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Property syntax</span></span><br><span class="line"><span class="keyword">property</span> &lt;name_of_property&gt;</span><br><span class="line">  &lt;test expression&gt; <span class="keyword">or</span></span><br><span class="line">  &lt;<span class="keyword">sequence</span> expressions&gt;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Assert the property</span></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span> (&lt;name_of_property&gt;);</span><br></pre></td></tr></table></figure>

<p><strong>属性要在断言声明中被调用才能发挥作用，否则它们会被编译器忽略掉。</strong></p>
<blockquote>
<p>断言的声明由下面任一一种关键字进行：assert，assume，cover。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertion_name: assert property (property_name);</span><br></pre></td></tr></table></figure>



<p>有两种断言类型，分别是<strong>即时断言</strong>和<strong>并发断言</strong>。</p>
<p><strong>Immediate Assertion</strong></p>
<p>​	即时断言的执行方式类似于过程块中的语句，并且遵循仿真事件语义。它们用于在仿真期间验证即时属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">always @ (&lt;some_event&gt;) begin</span><br><span class="line">	...</span><br><span class="line">	// This is an immediate assertion executed only</span><br><span class="line">	// at this point in the execution flow</span><br><span class="line">	$assert(!fifo_empty);      // Assert that fifo is not empty at this point</span><br><span class="line">	...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>Concurrent Assertion</strong></p>
<p>​	<strong>并发断言</strong>基于时钟语义，并使用其表达式的采样值。电路行为是通过 SystemVerilog 属性来描述的，这些属性会在给定的时钟信号每次触发时进行评估。如果在仿真过程中出现失败情况，则表明所描述的功能行为被违反了。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define a property to specify that an ack should be</span></span><br><span class="line"><span class="comment">// returned for every grant within 1:4 clocks</span></span><br><span class="line"><span class="keyword">property</span> p_ack;</span><br><span class="line">	@(<span class="keyword">posedge</span> clk) gnt ##[<span class="number">1</span>:<span class="number">4</span>] ack;</span><br><span class="line"><span class="keyword">endproperty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="keyword">property</span>(p_ack);    <span class="comment">// Assert the given property is true always</span></span><br></pre></td></tr></table></figure>

<p><strong>创建断言的步骤：</strong></p>
<ul>
<li><strong>第1步：创建boolean表达式</strong></li>
<li><strong>第2步：创建sequence表达式</strong></li>
<li><strong>第3步：创建属性property</strong></li>
<li><strong>第4步：断言声明property</strong></li>
</ul>
<h3 id="（二）即时断言（Immediate-Assertion）"><a href="#（二）即时断言（Immediate-Assertion）" class="headerlink" title="（二）即时断言（Immediate Assertion）"></a>（二）即时断言（Immediate Assertion）</h3><p>​	即时断言基于模拟事件语义学执行，并且需要在过程块中指定。在模拟期间，它的处理方式与if语句中的表达式相同。</p>
<p>​	如果表达式在执行语句时为真，则立即断言将通过，如果表达式的计算结果为假（X、Z或0），则立即断言将失败。这些断言旨在用于模拟，不适合形式验证。它可以在RTL代码和testbench中用于标记模拟中的错误。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Simple assert statement</span></span><br><span class="line"><span class="keyword">assert</span>(&lt;expression&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assert statement with statements to be executed for pass/fail conditions</span></span><br><span class="line"><span class="keyword">assert</span>(&lt;expression&gt;) <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// If condition is true, execute these statements</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">	<span class="comment">// If condition is false, execute these statements</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally give name for the assertion可选地为断言命名</span></span><br><span class="line">[assert_name] : <span class="keyword">assert</span>(&lt;expression&gt;);</span><br></pre></td></tr></table></figure>



<p><strong>Immediate Assertion in Design</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> _if<span class="variable">.clk</span>) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (_if<span class="variable">.push</span>) <span class="keyword">begin</span></span><br><span class="line">  	<span class="comment">// Immediate assertion and ensures that</span></span><br><span class="line">  	<span class="comment">// fifo is not full when push is 1</span></span><br><span class="line">  	a_push: <span class="keyword">assert</span> (!_if<span class="variable">.full</span>) <span class="keyword">begin</span></span><br><span class="line">    		<span class="built_in">$display</span>(<span class="string">&quot;[PASS] push when fifo not full&quot;</span>);</span><br><span class="line">  	<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    		<span class="built_in">$display</span>(<span class="string">&quot;[FAIL] push when fifo full !&quot;</span>);</span><br><span class="line">  	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>Immediate Assertion in Testbench</strong></p>
<p>可以在随机化方法调用上放置一个立即断言，以确保返回值始终为1，表示随机化成功。如果断言失败，它会提示用户首先查看失败，从而减少调试工作。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constraint</span> c_addr &#123; addr &gt; <span class="number">5</span>; addr &lt; <span class="number">3</span>; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Packet m_pkt = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(m_pkt<span class="variable">.randomize</span>());</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>如果用户未指定，模拟器会为断言分配一个生成的名称。</p>
<p>以类似的方式，<code>assert</code>可以与过程块中计算结果为真或假的任何表达式一起使用。</p>
<h3 id="（三）并发断言（Concurrent-Assertion）"><a href="#（三）并发断言（Concurrent-Assertion）" class="headerlink" title="（三）并发断言（Concurrent Assertion）"></a>（三）并发断言（Concurrent Assertion）</h3><p>​	<strong>并发断言（Concurrent Assertions）<strong>是SV中一种强大的验证机制，用于描述和检查跨越仿真时间的行为。与</strong>及时断言（Immediate Assertions）<strong>不同，并发断言通常与时钟同步，在特定的时间点（如</strong>时钟边沿</strong>）评估复杂的条件序列或属性。它们广泛应用于<strong>动态验证</strong>和<strong>形式验证</strong>中，帮助检测设计中的复杂行为问题。</p>
<h4 id="（1）并发断言的基本概念"><a href="#（1）并发断言的基本概念" class="headerlink" title="（1）并发断言的基本概念"></a>（1）<strong>并发断言的基本概念</strong></h4><p><strong>1、时序行为</strong>：</p>
<p>并发断言主要用于描述跨越多个时钟周期的行为模式。</p>
<p><strong>2、基于时钟边沿的评估</strong>：</p>
<p>并发断言在每个时钟边沿评估其条件，而不是立即评估。</p>
<p><strong>3、表达式形式</strong>：</p>
<p>并发断言使用属性（properties）、序列（sequences）等高级结构来定义复杂的时序关系。</p>
<p><strong>4、内置响应</strong>：</p>
<p>当断言失败时，可以触发内置的响应，如打印消息、停止仿真等。</p>
<h4 id="（2）并发断言的关键特性"><a href="#（2）并发断言的关键特性" class="headerlink" title="（2）并发断言的关键特性"></a><strong>（2）并发断言的关键特性</strong></h4><p><strong>1、属性（Properties）</strong>：</p>
<p>属性是并发断言的核心，用于定义需要验证的行为。属性可以包含序列、布尔表达式和其他属性。</p>
<p><strong>2、序列（Sequences）</strong>：</p>
<p>序列是一组连续事件的描述，通常用于定义复杂的时序关系。</p>
<p><strong>3、时钟和复位控制</strong>：</p>
<p>并发断言通常与时钟信号同步，并可以通过复位信号控制其启用状态。</p>
<h4 id="（3）并发断言的语法"><a href="#（3）并发断言的语法" class="headerlink" title="（3）并发断言的语法"></a>（3）并发断言的语法</h4><p><strong>1、定义序列（Sequence）</strong></p>
<p>序列用于描述一组连续事件的发生顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequence seq_name;</span><br><span class="line">    // 序列定义</span><br><span class="line">endsequence</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequence req_to_ack;</span><br><span class="line">    req ##[1:3] ack; // 在 req 信号之后 1 到 3 个时钟周期内出现 ack 信号</span><br><span class="line">endsequence</span><br></pre></td></tr></table></figure>

<p><strong>2、定义属性（Property）</strong></p>
<p>属性用于定义需要验证的行为，通常包含一个或多个序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property prop_name;</span><br><span class="line">    // 属性定义</span><br><span class="line">endproperty</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property check_req_to_ack;</span><br><span class="line">    @(posedge clk) disable iff (!reset_n) req_to_ack; // 在时钟上升沿检查 req_to_ack 序列</span><br><span class="line">endproperty</span><br></pre></td></tr></table></figure>

<p><strong>3、断言属性（Assert Property）</strong></p>
<p>使用 <code>assert property</code> 来声明并启用属性断言。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert property (prop_name) else $display(&quot;Error message&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert property (check_req_to_ack) else $display(&quot;Error: No ACK after REQ within 3 cycles at time %0t&quot;, $time);</span><br></pre></td></tr></table></figure>

<p><strong>示例：完整的并发断言示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">module example (</span><br><span class="line">    input clk,</span><br><span class="line">    input reset_n,</span><br><span class="line">    input req,</span><br><span class="line">    input ack</span><br><span class="line">);</span><br><span class="line">    // 定义一个序列，要求在 req 信号之后 1 到 3 个时钟周期内出现 ack 信号</span><br><span class="line">    sequence req_to_ack;</span><br><span class="line">        req ##[1:3] ack;</span><br><span class="line">    endsequence</span><br><span class="line"></span><br><span class="line">    // 定义一个属性，要求在时钟上升沿且复位信号有效时，满足 req_to_ack 序列</span><br><span class="line">    property check_req_to_ack;</span><br><span class="line">        @(posedge clk) disable iff (!reset_n) req_to_ack;</span><br><span class="line">    endproperty</span><br><span class="line"></span><br><span class="line">    // 启用属性断言</span><br><span class="line">    assert property (check_req_to_ack) else $display(&quot;Error: No ACK after REQ within 3 cycles at time %0t&quot;, $time);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h4 id="（4）关键概念详解"><a href="#（4）关键概念详解" class="headerlink" title="（4）关键概念详解"></a><strong>（4）关键概念详解</strong></h4><p><strong>1、时钟和复位控制</strong></p>
<p>并发断言通常与时钟信号同步，并可以通过复位信号控制其启用状态。<code>@(posedge clk)</code> 表示断言将在时钟的上升沿进行评估，而 <code>disable iff (!reset_n)</code> 表示当复位信号无效时禁用断言。</p>
<p><strong>2、序列（Sequence）</strong></p>
<p>序列用于描述一组连续事件的发生顺序。常见的序列运算符包括：</p>
<ul>
<li><code>##n</code>：表示 n 个时钟周期后。</li>
<li><code>[*m:n]</code>：表示事件重复 m 到 n 次。</li>
<li><code>[*]</code>：表示事件无限重复。</li>
<li><code>-&gt;</code>：表示前一个事件导致后一个事件发生。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequence burst;</span><br><span class="line">    req ##1 (ack [*3]) ##1 done; // req 后跟 3 次 ack，然后是 done</span><br><span class="line">endsequence</span><br></pre></td></tr></table></figure>

<p><strong>3. 属性（Property）</strong></p>
<p>属性用于定义需要验证的行为，通常包含一个或多个序列。常见的属性运算符包括：</p>
<ul>
<li><code>|-&gt;</code>：表示前一个事件导致后一个事件发生（强因果关系）。</li>
<li><code>|=&gt;</code>：表示前一个事件导致后一个事件在下一个时钟周期发生（弱因果关系）。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property check_burst;</span><br><span class="line">    @(posedge clk) disable iff (!reset_n) req |-&gt; burst;</span><br><span class="line">endproperty</span><br></pre></td></tr></table></figure>

<p><strong>4. 嵌套断言</strong></p>
<p>可以在同一个块中嵌套多个断言，以检查多个条件。</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">module example (</span><br><span class="line">    input clk,</span><br><span class="line">    input reset_n,</span><br><span class="line">    input req,</span><br><span class="line">    input ack,</span><br><span class="line">    input valid</span><br><span class="line">);</span><br><span class="line">    sequence req_to_ack;</span><br><span class="line">        req ##[1:3] ack;</span><br><span class="line">    endsequence</span><br><span class="line"></span><br><span class="line">    property check_req_to_ack;</span><br><span class="line">        @(posedge clk) disable iff (!reset_n) req_to_ack;</span><br><span class="line">    endproperty</span><br><span class="line"></span><br><span class="line">    sequence valid_data;</span><br><span class="line">        valid &amp;&amp; data != 0;</span><br><span class="line">    endsequence</span><br><span class="line"></span><br><span class="line">    property check_valid_data;</span><br><span class="line">        @(posedge clk) disable iff (!reset_n) valid_data;</span><br><span class="line">    endproperty</span><br><span class="line"></span><br><span class="line">    assert property (check_req_to_ack) else $display(&quot;Error: No ACK after REQ within 3 cycles at time %0t&quot;, $time);</span><br><span class="line">    assert property (check_valid_data) else $display(&quot;Error: Invalid data detected at time %0t&quot;, $time);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h4 id="（5）动态验证与形式验证"><a href="#（5）动态验证与形式验证" class="headerlink" title="（5）动态验证与形式验证"></a>（5）动态验证与形式验证</h4><p>并发断言不仅适用于传统的动态仿真验证，还可以用于形式验证技术。形式验证通过数学分析方法证明设计的正确性，而不是依赖于仿真运行的结果。</p>
<ul>
<li><strong>动态验证</strong>：通过仿真运行来验证设计行为。</li>
<li><strong>形式验证</strong>：通过数学分析来验证设计是否符合预期。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>动态验证</th>
<th>形式验证</th>
</tr>
</thead>
<tbody><tr>
<td><strong>验证方法</strong></td>
<td>基于仿真，通过运行测试向量进行验证</td>
<td>基于数学证明，通过静态分析进行验证</td>
</tr>
<tr>
<td><strong>覆盖范围</strong></td>
<td>依赖于测试向量，覆盖范围有限</td>
<td>全面覆盖所有可能的状态和路径</td>
</tr>
<tr>
<td><strong>计算资源</strong></td>
<td>需要大量计算资源和时间</td>
<td>高效利用资源，不需要大量仿真时间</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>灵活，适合多种验证场景</td>
<td>复杂度较高，适用于特定模块或小规模设计</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>适用于大规模系统级设计</td>
<td>适用于较小规模的设计或特定模块</td>
</tr>
<tr>
<td><strong>工具支持</strong></td>
<td>普通仿真工具即可</td>
<td>需要专门的形式验证工具</td>
</tr>
</tbody></table>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>并发断言（Concurrent Assertions）</strong> 是 SystemVerilog 中的一种验证机制，用于描述和检查跨越仿真时间的行为。</li>
<li>并发断言通常与时钟同步，在每个时钟边沿评估复杂的条件序列或属性。</li>
<li>使用**属性（properties）<strong>和</strong>序列（sequences）**来定义复杂的时序关系。</li>
<li><strong>并发断言</strong>可以放置在模块、接口或程序块中，并且既适用于<strong>动态验证</strong>也适用于<strong>形式验证</strong>。</li>
</ul>
<h3 id="（四）常用系统函数"><a href="#（四）常用系统函数" class="headerlink" title="（四）常用系统函数"></a>（四）常用系统函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// rose 当信号/表达式由上一个时钟周期的‘0’变成当前周期的‘1’时返回真。 </span><br><span class="line">$rose(boolean_expression or signal)   </span><br><span class="line">// fell 当信号/表达式由上一个时钟周期的‘1’变成当前周期的‘0’返回真。</span><br><span class="line">$fell(boolean_expression or signal)   </span><br><span class="line">// 当信号/表达式的值和上一个时钟周期相同返回真。</span><br><span class="line">$stable(boolean_expression or signal) </span><br><span class="line">// 当信号/表达式的值改变返回真。（=== ~$stable()）</span><br><span class="line">$changed(boolean_expression or signal)</span><br><span class="line">//可以得到信号在几个时钟周期之前的值。在默认情况下，它提供信号在前一个时钟周期的值。</span><br><span class="line">$past(signal_name，number of clock cycles)</span><br><span class="line">// 检验表达式的任何位是否是X或者Z</span><br><span class="line">$isunknown(expression)</span><br><span class="line">// 在任意给定的时钟沿，表达式只有一位为高。</span><br><span class="line">$onehot(expression)</span><br><span class="line">// 在任意给定的时钟沿，表达式只有一位为高或者没有任何位为高。</span><br><span class="line">$onehot0(expression)</span><br><span class="line">// 计数等于1的位</span><br><span class="line">$countones(expression)</span><br><span class="line">// 计数指定位的出现次数</span><br><span class="line">$countbits(expression, val1, val2,...)</span><br><span class="line">// 当且仅当表达式在列表中返回真。</span><br><span class="line">expression inside list</span><br><span class="line">eg: safe_opcode = opcode inside &#123;ADD,SUB,MUL&#125;</span><br><span class="line">	S</span><br><span class="line">sequence s2;</span><br><span class="line">	@(posedge clk) $rose(a);//从0变为1</span><br><span class="line">endsequence</span><br><span class="line"></span><br><span class="line">property p12;</span><br><span class="line">    @(posedge clk) (a&amp;&amp;b) |-&gt; ##[1:3] c;</span><br><span class="line">endproperty</span><br></pre></td></tr></table></figure>

<p><code>Sequence</code>是 SystemVerilog 断言中的一个基本构建块，它可以表示特定的表达式，以帮助创建更复杂的属性。</p>
<p><strong>Simple sequence</strong></p>
<p><strong>Complex sequence</strong></p>
<h3 id="（五）在“时序逻辑”中判断多个序列-信号的行为关系"><a href="#（五）在“时序逻辑”中判断多个序列-信号的行为关系" class="headerlink" title="（五）在“时序逻辑”中判断多个序列&#x2F;信号的行为关系"></a>（五）在“时序逻辑”中判断多个序列&#x2F;信号的行为关系</h3><h4 id="（1）表示序列间的关系"><a href="#（1）表示序列间的关系" class="headerlink" title="（1）表示序列间的关系"></a>（1）表示序列间的关系</h4><ul>
<li><strong>s1 and s2</strong> 当两个序列都成功时整个属性才成功。两个序列必须具有相同的起始点，但是可以有不同的结束点。检验的起始点是第一个序列的成功时的起始点，而检验的结束点是使得属性最终成功的另一个序列成功时的点。</li>
<li><strong>s1 or s2</strong> 只要其中一个序列成功，整个属性就成功。</li>
<li><strong>s1 intersect s2</strong> 断定两个序列在相同时刻开始，且结束于同一时刻。（两个序列的长度必须相等）</li>
<li><strong>s1 within s2</strong> 表示在s2的整个序列内出现过s1。</li>
<li><strong>s1 throughout s2</strong> 表示在s2整个序列内，s1一直成立。（蕴含只在时钟边沿检验前提条件一次，然后就开始检验后续算子部分，因此它不检测先行算子是否一直保持为真。为了保证某些条件在整个序列的验证过程中一直为真，可以使用“throughout”运算符。）</li>
</ul>
<h4 id="（2）延迟的用法"><a href="#（2）延迟的用法" class="headerlink" title="（2）延迟的用法"></a>（2）延迟的用法</h4><ul>
<li><strong>a ##2 b</strong> 断定a事件发生后2个单位时间内b事件一定会发生。</li>
<li><strong>a ##[1:3] b</strong> 断定a事件发生后1~3个单位时间内b事件一定会发生。</li>
<li><strong>a ##[1:$] b</strong> $表示无穷大。断定a事件发生后b事件一定会发生。</li>
</ul>
<h4 id="（3）重复运算符"><a href="#（3）重复运算符" class="headerlink" title="（3）重复运算符"></a>（3）重复运算符</h4><ul>
<li><strong>连续重复运算符：</strong></li>
</ul>
<p>​	**a[*n]：**信号a在连续n个时钟周期内都成立。</p>
<p>​	**a[*n:m]：**表示a连续出现n到m次，这里n,m为常数。</p>
<ul>
<li><strong>跟随重复运算符：</strong></li>
</ul>
<p>​	<strong>a[-&gt;3]</strong> a连续或间断地出现3次为高，在最后一个a结束的时间点。</p>
<ul>
<li><strong>非连续重复运算符：</strong></li>
</ul>
<p>​	**a[&#x3D;3]**表示在信号a出现了3次之后的任意时间点。</p>
<p>​	非连续重复与跟随重复相似，除了它并不要求信号的最后一次重复匹配发生在整个序列匹配前的那个时钟周期。</p>
<h4 id="（4）蕴含操作符"><a href="#（4）蕴含操作符" class="headerlink" title="（4）蕴含操作符"></a>（4）蕴含操作符</h4><p>​	<strong>蕴含</strong>等效于一个if-then结构。蕴含的左边叫作“先行算子”（antecedent），右边叫作“后续算子”（consequent）。先行算子是约束条件。当先行算子成功时，后续算子才会被计算。如果先行算子不成功，那么整个属性就默认地被认为成功。这叫作“空成功”（vacuous success）。蕴含结构只能被用在属性定义中，不能在序列中使用。</p>
<p>​	<strong>蕴含</strong>可以分为两类：<strong>交叠蕴含</strong>（Overlapped implication）和<strong>非交叠蕴含</strong>（Non-overlapped implication）。</p>
<ul>
<li><strong>交叠蕴含：</strong></li>
</ul>
<p><strong>|-&gt;: s1 |-&gt; s2</strong> 表示s1为真的同一时刻，s2必须为真，s1为假的时候，s2可真可假。</p>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if a</span><br><span class="line">  b;</span><br><span class="line">else</span><br><span class="line">  succeed;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非交叠蕴含：</strong></li>
</ul>
<p><strong>|&#x3D;&gt;: s1 |&#x3D;&gt; s2</strong> 表示在s1为真的下一个时钟周期s2必须为真，s1为假的下一个时钟周期，s2可真可假。等价于：<strong>s1 |-&gt; ##1 s2</strong></p>
<h4 id="（5）”disable-iff“构造"><a href="#（5）”disable-iff“构造" class="headerlink" title="（5）”disable iff“构造"></a>（5）”disable iff“构造</h4><p>在某些设计情况中，如果一些条件为真，则我们不想执行检验。换句话说，这就像是一个异步的复位，使得检验在当前时刻不工作。SVA提供了关键词“disable iff”来实现这种检验器的异步复位。</p>
<p><strong>“disable iff”的基本语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable iff(expression)&lt;property definition0&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（六）简单SVA举例"><a href="#（六）简单SVA举例" class="headerlink" title="（六）简单SVA举例"></a>（六）简单SVA举例</h3><p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185743312&content_type=Article&match_order=1&q=FIFO&zhida_source=entity">FIFO</a>的验证：</p>
<p><strong>1、检查FIFO满时不再写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check_enqueue_no_wr: assert property (@posedge clk) disable iff(!rst_n) </span><br><span class="line">full |-&gt; !wr);</span><br></pre></td></tr></table></figure>

<p><strong>2、检查FIFO空时不再读：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check_dequeue_no_rd: assert property (@posedge clk) disable iff(!rst_n) </span><br><span class="line">empty |-&gt; !rd);</span><br></pre></td></tr></table></figure>



<h2 id="十二、Testbench示例"><a href="#十二、Testbench示例" class="headerlink" title="十二、Testbench示例"></a>十二、Testbench示例</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huang-commits.github.io">huangrj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huang-commits.github.io/2025/03/24/Systemverilog/">https://huang-commits.github.io/2025/03/24/Systemverilog/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huang-commits.github.io" target="_blank">RJ's rotten pen</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Systemverilog/">Systemverilog</a><a class="post-meta__tags" href="/tags/testbench/">testbench</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/24/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">huangrj</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">（1）Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Systemverilog-Testbench"><span class="toc-number">1.2.</span> <span class="toc-text">（2）Systemverilog Testbench</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">二、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、控制流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89-Loops"><span class="toc-number">3.1.</span> <span class="toc-text">（一） Loops</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89break-continue"><span class="toc-number">3.2.</span> <span class="toc-text">（二）break, continue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89if-else-if"><span class="toc-number">3.3.</span> <span class="toc-text">（三）if-else-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89case"><span class="toc-number">3.4.</span> <span class="toc-text">（四）case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89Blocking-Non-blocking-Statements"><span class="toc-number">3.5.</span> <span class="toc-text">（五）Blocking &amp; Non-blocking Statements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89Functions"><span class="toc-number">3.6.</span> <span class="toc-text">（六）Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89Tasks"><span class="toc-number">3.7.</span> <span class="toc-text">（七）Tasks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Processes"><span class="toc-number">4.</span> <span class="toc-text">四、Processes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89systemverilog-thread"><span class="toc-number">4.1.</span> <span class="toc-text">（一）systemverilog thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Disable-fork-join"><span class="toc-number">4.2.</span> <span class="toc-text">（二）Disable fork join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Wait-fork"><span class="toc-number">4.3.</span> <span class="toc-text">（三）Wait fork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%80%9A%E4%BF%A1"><span class="toc-number">5.</span> <span class="toc-text">五、通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.1.</span> <span class="toc-text">（一）进程间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Event"><span class="toc-number">5.2.</span> <span class="toc-text">（二）Event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Semaphores%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">（三）Semaphores信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Mailboxes"><span class="toc-number">5.4.</span> <span class="toc-text">（四）Mailboxes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.1.</span> <span class="toc-text">1. 基础数据结构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%B7%AE%E5%BC%82"><span class="toc-number">5.4.2.</span> <span class="toc-text">2. 底层实现差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E7%BA%A6%E6%9D%9F"><span class="toc-number">5.4.3.</span> <span class="toc-text">3. 关键设计约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-number">6.</span> <span class="toc-text">六、接口(Interface)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Interface"><span class="toc-number">6.1.</span> <span class="toc-text">（一）Interface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Introduction"><span class="toc-number">6.2.</span> <span class="toc-text">（二）Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Interface-bundles-%E6%8E%A5%E5%8F%A3%E6%8D%86%E7%BB%91"><span class="toc-number">6.3.</span> <span class="toc-text">（三）Interface bundles(接口捆绑)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Modports"><span class="toc-number">6.4.</span> <span class="toc-text">（四）Modports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89Clocking-Blocks"><span class="toc-number">6.5.</span> <span class="toc-text">（五）Clocking Blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89CLocking-Blocks-II"><span class="toc-number">6.6.</span> <span class="toc-text">（六）CLocking Blocks II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">七、面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Class"><span class="toc-number">7.1.</span> <span class="toc-text">（一）Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Constructors%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">（二）Constructors构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89This%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.3.</span> <span class="toc-text">（三）This关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Polymorphism%E5%A4%9A%E6%80%81"><span class="toc-number">7.4.</span> <span class="toc-text">（四）Polymorphism多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E8%99%9A%E6%96%B9%E6%B3%95virtual-method"><span class="toc-number">7.5.</span> <span class="toc-text">（五）虚方法virtual method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%88%96%E5%87%BD%E6%95%B0Static-Variables-Function"><span class="toc-number">7.6.</span> <span class="toc-text">（六）静态变量或函数Static Variables &amp; Function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Static-Variables%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">7.6.1.</span> <span class="toc-text">1、Static Variables静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Static-function%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.2.</span> <span class="toc-text">2、Static function静态函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.3.</span> <span class="toc-text">3、静态变量和静态函数的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.6.4.</span> <span class="toc-text">4、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9DShallow-Deep-Copy"><span class="toc-number">7.7.</span> <span class="toc-text">（七）深拷贝与浅拷贝Shallow&#x2F;Deep Copy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-number">7.7.1.</span> <span class="toc-text">1、浅拷贝（Shallow Copy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">7.7.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-number">7.7.3.</span> <span class="toc-text">2、深拷贝（Deep Copy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">7.7.4.</span> <span class="toc-text">3、特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%80%BB%E7%BB%93-1"><span class="toc-number">7.7.5.</span> <span class="toc-text">4、总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%EF%BC%88Parameterized-Classes%EF%BC%89"><span class="toc-number">7.8.</span> <span class="toc-text">（八）参数化类（Parameterized Classes）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89local%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">7.9.</span> <span class="toc-text">（九）local标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88Abstract-class%EF%BC%89"><span class="toc-number">7.10.</span> <span class="toc-text">（十）抽象类（Abstract class）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BA%A6%E6%9D%9F%EF%BC%88Constraints%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">八、约束（Constraints）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%88Random-variable%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">（一）随机变量（Random variable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%A6%E6%9D%9F%E5%9D%97%EF%BC%88Constraint-block%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">（二）约束块（Constraint block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%95%B0%E7%BB%84%E9%9A%8F%E6%9C%BA%E5%8C%96%EF%BC%88Array-Randomization%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">（三）数组随机化（Array Randomization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%B8%E8%A7%81%E7%BA%A6%E6%9D%9F%EF%BC%88Common-Constraints%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">（四）常见约束（Common Constraints）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%85%E9%83%A8%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.5.</span> <span class="toc-text">（五）内部约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E8%95%B4%E5%90%AB%E7%BA%A6%E6%9D%9FImplication-Constraint"><span class="toc-number">8.6.</span> <span class="toc-text">（六）蕴含约束Implication Constraint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89foreach%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.7.</span> <span class="toc-text">（七）foreach约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AB%EF%BC%89solve-before-Constraint%E5%85%88%E6%B1%82%E8%A7%A3%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.8.</span> <span class="toc-text">（八）solve before Constraint先求解约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B9%9D%EF%BC%89Static-Constraints%E9%9D%99%E6%80%81%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.9.</span> <span class="toc-text">（九）Static Constraints静态约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%EF%BC%89Randomization-Methods"><span class="toc-number">8.10.</span> <span class="toc-text">（十）Randomization Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89Inline-Constraints%E5%86%85%E8%81%94%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.11.</span> <span class="toc-text">（十一）Inline Constraints内联约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89Soft-Constraints%E8%BD%AF%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.12.</span> <span class="toc-text">（十二）Soft Constraints软约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89Disable-Constraints"><span class="toc-number">8.13.</span> <span class="toc-text">（十三）Disable Constraints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89Disable-Randomization"><span class="toc-number">8.14.</span> <span class="toc-text">（十四）Disable Randomization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89Random-Weighted-Case"><span class="toc-number">8.15.</span> <span class="toc-text">（十五）Random Weighted Case</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Misc-Constructs"><span class="toc-number">9.</span> <span class="toc-text">九、Misc Constructs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89Program-Block"><span class="toc-number">9.1.</span> <span class="toc-text">（一）Program Block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Cast-Dynamic"><span class="toc-number">9.2.</span> <span class="toc-text">（二）Cast Dynamic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Package"><span class="toc-number">9.3.</span> <span class="toc-text">（三）Package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89Commandline-Input-%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="toc-number">9.4.</span> <span class="toc-text">（四）Commandline Input(命令行输入)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89File-Operation"><span class="toc-number">9.5.</span> <span class="toc-text">（五）File Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89SystemVerilog-Callback"><span class="toc-number">9.6.</span> <span class="toc-text">（六）SystemVerilog Callback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87%EF%BC%88Functional-Coverage%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">十、功能覆盖率（Functional Coverage）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-number">10.1.</span> <span class="toc-text">（一）功能覆盖率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89Covergroup-Coverpoint"><span class="toc-number">10.2.</span> <span class="toc-text">（二）Covergroup &amp; Coverpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89Coverpoint-bins%EF%BC%88%E8%A6%86%E7%9B%96%E6%A1%B6%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">（三）Coverpoint bins（覆盖桶）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%96%AD%E8%A8%80%EF%BC%88Assertions%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">十一、断言（Assertions）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">（一）介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8D%B3%E6%97%B6%E6%96%AD%E8%A8%80%EF%BC%88Immediate-Assertion%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">（二）即时断言（Immediate Assertion）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E5%B9%B6%E5%8F%91%E6%96%AD%E8%A8%80%EF%BC%88Concurrent-Assertion%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">（三）并发断言（Concurrent Assertion）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%B9%B6%E5%8F%91%E6%96%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.3.1.</span> <span class="toc-text">（1）并发断言的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B9%B6%E5%8F%91%E6%96%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">11.3.2.</span> <span class="toc-text">（2）并发断言的关键特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E5%B9%B6%E5%8F%91%E6%96%AD%E8%A8%80%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">11.3.3.</span> <span class="toc-text">（3）并发断言的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.3.4.</span> <span class="toc-text">（4）关键概念详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E5%8A%A8%E6%80%81%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81"><span class="toc-number">11.3.5.</span> <span class="toc-text">（5）动态验证与形式验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0"><span class="toc-number">11.4.</span> <span class="toc-text">（四）常用系统函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89%E5%9C%A8%E2%80%9C%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E2%80%9D%E4%B8%AD%E5%88%A4%E6%96%AD%E5%A4%9A%E4%B8%AA%E5%BA%8F%E5%88%97-%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%A1%8C%E4%B8%BA%E5%85%B3%E7%B3%BB"><span class="toc-number">11.5.</span> <span class="toc-text">（五）在“时序逻辑”中判断多个序列&#x2F;信号的行为关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%A1%A8%E7%A4%BA%E5%BA%8F%E5%88%97%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.5.1.</span> <span class="toc-text">（1）表示序列间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%BB%B6%E8%BF%9F%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">11.5.2.</span> <span class="toc-text">（2）延迟的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E9%87%8D%E5%A4%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.5.3.</span> <span class="toc-text">（3）重复运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%95%B4%E5%90%AB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">11.5.4.</span> <span class="toc-text">（4）蕴含操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E2%80%9Ddisable-iff%E2%80%9C%E6%9E%84%E9%80%A0"><span class="toc-number">11.5.5.</span> <span class="toc-text">（5）”disable iff“构造</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%85%AD%EF%BC%89%E7%AE%80%E5%8D%95SVA%E4%B8%BE%E4%BE%8B"><span class="toc-number">11.6.</span> <span class="toc-text">（六）简单SVA举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Testbench%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.</span> <span class="toc-text">十二、Testbench示例</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/Systemverilog/" title="Systemverilog">Systemverilog</a><time datetime="2025-03-24T08:50:20.000Z" title="发表于 2025-03-24 16:50:20">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-24T06:07:58.978Z" title="发表于 2025-03-24 14:07:58">2025-03-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By huangrj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>